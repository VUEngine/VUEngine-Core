{%- import 'templates/partials/macros.nj' as macros -%}
{% include('templates/partials/fileHeader.c.nj') %}

{%- set entityName = entity.name | toUpperSnakeCase -%}
{%- set spriteTypes = [] -%}
{%- for sprite in entity.sprites -%}
	{%- set spriteTypes = (spriteTypes.push(sprite.type), spriteTypes) -%}
{%- endfor %}


{{ macros.sectionHeader('Includes') }}

#include <Libgccvb.h>
#include <FinishLine.h>
{% for spriteType in spriteTypes | unique -%}
#include <{{ spriteType }}.h>
{%- endfor %}


{{ macros.sectionHeader('Declarations') }}

{% for sprite in entity.sprites -%}
extern uint32 {{ sprite.texture.image.name }}Tiles[];
extern uint16 {{ sprite.texture.image.name }}Map[];
{% endfor %}

{% if entity.animations.definitions.length -%}
{{ macros.sectionHeader('Animations') }}

{% for animation in entity.animations.definitions -%}
AnimationFunctionROMSpec {{ entityName }}{{ animation.name | toUpperSnakeCase }}Animation =
{
	// number of frames of this animation function
	{{ animation.frames.length }},

	// frames to play in animation
	{
		{{ animation.frames }}
	},

	// number of cycles a frame of animation is displayed
	{{ animation.cycles }},

	// whether to play it in loop or not
	{{ animation.loop }},

	// method to call on function completion
	{% if animation.callback %}(EventListener){{ animation.callback }}{% else %}NULL{% endif %},

	// function's name
	"{{ animation.name }}",
};

{% endfor -%}

AnimationDescriptionROMSpec {{ entityName }}Animations =
{
	{
		{% for animation in entity.animations.definitions -%}
			(AnimationFunction*)&{{ entityName }}{{ animation.name | toUpperSnakeCase }}Animation,
		{% endfor -%}
		NULL
	}
};
{% endif %}

{% if entity.sprites.length -%}
{{ macros.sectionHeader('Sprites') }}

{% set spriteNames = [] -%}
{%- for sprite in entity.sprites -%}

{%- if sprite.name -%}
	{%- set spriteName = entity.name ~ sprite.name -%}
{%- elseif entity.sprites.length > 1-%}
	{%- set spriteName = entity.name ~ loop.index -%}
{%- else -%}
	{%- set spriteName = entity.name -%}
{%- endif -%}
{%- set spriteName = spriteName | toUpperSnakeCase -%}
{%- set spriteNames = (spriteNames.push(spriteName), spriteNames) -%}

CharSetROMSpec {{ spriteName }}Charset =
{
	// number of chars, depending on allocation type:
	// __ANIMATED_SINGLE*, __ANIMATED_SHARED*: number of chars of a single animation frame (cols * rows)
	// __ANIMATED_MULTI, __NOT_ANIMATED: sum of all chars
	{% if sprite.texture.charset.type == 'animatedMulti' or sprite.texture.charset.type == 'notAnimated' -%}
	{{ sprite.texture.image.chars }},
	{%- else -%}
	{{ sprite.texture.size.x * sprite.texture.size.y }},
	{%- endif %}

	// allocation type
	// (__ANIMATED_SINGLE, __ANIMATED_SINGLE_OPTIMIZED, __ANIMATED_SHARED, __ANIMATED_SHARED_COORDINATED, __ANIMATED_MULTI or __NOT_ANIMATED)
	__{{ sprite.texture.charset.type | toUpperSnakeCase }},

	// char spec
	{{ sprite.texture.image.name }}Tiles,

	// pointer to the frames offsets
	NULL,
};

TextureROMSpec {{ spriteName }}Texture =
{
	// charset spec
	(CharSetSpec*)&{{ spriteName }}Charset,

	// bgmap spec
	{{ sprite.texture.image.name }}Map,

	// cols (max 64)
	{{ sprite.texture.size.x }},

	// rows (max 64)
	{{ sprite.texture.size.y }},

	// padding for affine/hbias transformations
	{
		{{ sprite.texture.padding.x }}, // cols
		{{ sprite.texture.padding.y }}, // rows
	},

	// number of frames, depending on charset's allocation type:
	// __ANIMATED_SINGLE*, __ANIMATED_SHARED*, __NOT_ANIMATED: 1
	// __ANIMATED_MULTI: total number of frames
	{% if sprite.texture.charset.type == 'animatedMulti' and entity.animations.definitions.length -%}
	{{ entity.animations.definitions.length }}
	{%- else -%}
	1,
	{%- endif %}

	// palette number (0-3)
	{{ sprite.texture.palette }},

	// recyclable
	{{ sprite.texture.recyclable }},

	// vertical flip
	false,

	// horizontal flip
	false,
};

{{ sprite.type | replace('Animated', '') }}ROMSpec {{ spriteName }}Sprite =
{
	{
		// sprite's type
		__TYPE({{ sprite.type }}),

		// texture spec
		(TextureSpec*)&{{ entityName }}Texture,

		// transparency (__TRANSPARENCY_NONE, __TRANSPARENCY_EVEN or __TRANSPARENCY_ODD)
		__TRANSPARENCY_{{ sprite.transparency }},

		// displacement
		{
			{{ sprite.displacement.x }}, // x
			{{ sprite.displacement.y }}, // y
			{{ sprite.displacement.z }}, // z
			{{ sprite.displacement.parallax }}, // parallax
		},
	},

	// bgmap mode (__WORLD_BGMAP, __WORLD_AFFINE, __WORLD_OBJECT or __WORLD_HBIAS)
	// make sure to use the proper corresponding sprite type throughout the spec (BgmapSprite or ObjectSprite)
	__WORLD_{{ sprite.bgmapMode }},

	{% if sprite.bgmapMode !== 'OBJECT' -%}
	// pointer to affine/hbias manipulation function
	{% if sprite.manipulationFunction %}(ParamTableEffectMethod){{ sprite.manipulationFunction }}{% else %}NULL{% endif %},
	{%- endif %}

	// display mode (__WORLD_ON, __WORLD_LON or __WORLD_RON)
	__WORLD_{{ sprite.displayMode }},
};

{% endfor -%}

BgmapSpriteROMSpec* const {{ entityName }}Sprites[] =
{
	{% for spriteName in spriteNames -%}
	&{{ spriteName }}Sprite,
	{% endfor -%}
	NULL
};
{%- endif %}


{{ macros.sectionHeader('Entity') }}

{{ entity.entity.class }}ROMSpec {{ entityName }}Entity =
{
	// animated entity
	{
		// entity
		{
			// class allocator
			__TYPE({{ entity.entity.class }}),

			// children
			NULL,

			// behaviors
			NULL,

			// extra
			NULL,

			// sprites
			(SpriteSpec**){{ entityName }}Sprites,

			// use z displacement in projection
			false,
			
			// collision shapes
			(ShapeSpec*)NULL,

			// size
			// if 0, width and height will be inferred from the first sprite's texture's size
			{
				{{ entity.entity.size.x }}, // x
				{{ entity.entity.size.y }}, // y
				{{ entity.entity.size.z }}, // z
			},

			// gameworld's character's type
			kType{{ entity.collisions.type }},

			// physical specification
			(PhysicalSpecification*)NULL,
		},

		// pointer to the animation spec for the item
		(AnimationDescription*)&{{ entityName }}Animations,

		// initial animation
		"{{ entity.animations.default }}",
	}
};
