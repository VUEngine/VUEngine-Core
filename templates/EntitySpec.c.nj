{%- import 'templates/partials/macros.nj' as macros -%}
{%- include('templates/partials/fileHeader/fileHeader.c.nj') -%}
{%- set sanitizedSpecName = item.name | sanitizeSpecName -%}

{#- DETERMINE SPRITE CLASS -#}
{%- set spriteClass = item.sprites.type ~ 'Sprite' -%}
{%- if item.sprites.customClass is defined and item.sprites.customClass != '' -%}
	{%- set spriteClass = item.sprites.customClass -%}
{%- endif -%}

{#- DETERMINE INCLUDES -#}
{%- set includes = [spriteClass, 'Entity', 'Texture'] -%}
{%- if item.colliders.inGameType != 'None' -%}
	{%- set includes = (includes.push('InGameTypes'), includes) -%}
{%- endif %}
{%- if item.physics.enabled -%}
	{%- set includes = (includes.push('Body'), includes) -%}
{%- endif %}
{%- if item.colliders.inGameType != 'None' and item.colliders.colliders.length %}
	{%- for collider in item.colliders.colliders -%}
		{%- set includes = (includes.push(collider.type), includes) -%}
	{%- endfor -%}
{%- endif %}

{#- CONVERT IMAGES -#}
{%- set section = item.sprites.section -%}
{%- set compression = item.sprites.compression -%}
{%- set convertedFiles = {} -%}
{%- if item.sprites.sharedTiles -%}
	{%- set files = [] -%}
	{#- keep track of added files to be able to map back maps later -#}
	{%- set spriteFilesIndex = {} -%}
	{%- set mapCounter = 0 -%}
	{%- for sprite in item.sprites.sprites -%}
		{%- for file in sprite.texture.files -%}
			{#- there must only be only one file here -#}
			{%- if spriteFilesIndex[file] is not defined -%}
				{%- set files = (files.push(file), files) -%}
				{%- set spriteFilesIndex = spriteFilesIndex | setProperty(file, mapCounter) -%}
				{%- set mapCounter = mapCounter + 1 -%}
			{%- endif -%}
		{%- endfor -%}
	{%- endfor -%}
	{%- set conversionSettings = {
		"animation": {
			"frames": 0,
			"individualFiles": false,
			"isAnimation": false
		},
		"files": files,
		"map": {
			"compression": compression,
			"generate": true,
			"reduce": {
				"flipped": item.sprites.optimizedTiles,
				"unique": item.sprites.optimizedTiles
			}
		},
		"name": sanitizedSpecName,
		"section": section,
		"tileset": {
			"compression": compression,
			"shared": true
		}
	} -%}
	{%- set newImageData = itemUri | convertImage(conversionSettings) -%}
	{%- set newImageData = newImageData | setProperty('loopIndex', 1) -%}
	{%- set convertedFiles = {'0': newImageData} -%}
	{#- map imagedata back to sprites -#}
	{%- for sprite in item.sprites.sprites -%}
		{%- set slicedImageData = { animation: newImageData.animation, tiles: newImageData.tiles, maps: [newImageData.maps[spriteFilesIndex[sprite.texture.files[0]]]], loopIndex: newImageData.loopIndex } -%}
		{%- set sprite = sprite | setProperty('imageData', slicedImageData) -%}
	{%- endfor -%}
{%- else -%}
	{%- for sprite in item.sprites.sprites -%}
		{#- keep track of already converted files to avoid converting the same image twice -#}
		{%- set checksum = sprite.texture.files | crc32 -%}
		{%- if convertedFiles[checksum] is defined -%}
			{%- set sprite = sprite | setProperty('imageData', convertedFiles[checksum]) -%}
		{%- else -%}
			{%- set conversionSettings = {
				"animation": {
					"frames": sprite.texture.files.length,
					"individualFiles": sprite.texture.files.length > 1,
					"isAnimation": false
				},
				"files": sprite.texture.files,
				"map": {
					"compression": compression,
					"generate": true,
					"reduce": {
						"flipped": item.sprites.optimizedTiles,
						"unique": item.sprites.optimizedTiles
					}
				},
				"name": sanitizedSpecName,
				"section": section,
				"tileset": {
					"compression": compression,
					"shared": false
				}
			} -%}
			{%- set newImageData = itemUri | convertImage(conversionSettings) -%}
			{%- set newImageData = newImageData | setProperty('loopIndex', loop.index) -%}
			{%- set convertedFiles = convertedFiles | setProperty(checksum, newImageData) -%}
			{%- set sprite = sprite | setProperty('imageData', newImageData) -%}
		{%- endif -%}
	{%- endfor -%}
{%- endif -%}

{#- PRINT INCLUDES -#}
{%- if includes.length %}

{{ macros.sectionHeader('Includes') }}

{% for include in includes | unique | sort -%}
#include <{{ include }}.h>
{% endfor %}
{%- endif %}

{#- PRINT IMAGE DATA AND SPRITES -#}
{%- set allImageData = convertedFiles | values -%}
{%- if allImageData.length %}

{{ macros.sectionHeader('Image Data') }}
{% for imageData in allImageData -%}
	{%- set tilesName = sanitizedSpecName ~ 'Entity' ~ imageData.tiles.name -%}
	{%- set customMapPrefix = sanitizedSpecName ~ 'Entity' -%}
	{%- include('templates/partials/image/tiles.c.nj') -%}
	{%- include('templates/partials/image/maps.c.nj') -%}
	{%- include('templates/partials/image/frameOffsets.c.nj') -%}
{% endfor %}

{{ macros.sectionHeader('Sprites') }}

{% set spriteNames = [] -%}
{%- for sprite in item.sprites.sprites -%}
{%- set charsetSpecName = sanitizedSpecName ~ 'Sprite' ~ sprite.imageData.loopIndex ~ 'CharsetSpec' -%}
{%- set spriteName = sanitizedSpecName ~ 'Sprite' ~ loop.index -%}
{%- set spriteNames = (spriteNames.push(spriteName), spriteNames) -%}

{%- if sprite.imageData.loopIndex is defined and sprite.imageData.loopIndex === loop.index %}
CharSetROMSpec {{ charsetSpecName }} =
{
	// number of chars in function of the number of frames to load at the same time
	{{ sprite.imageData.tiles.count }},

	// whether it is shared or not
	{{ item.sprites.sharedTiles }},

	// whether the tiles are optimized or not
	{{ item.sprites.optimizedTiles }},

	// char spec
	(uint32*){{ sanitizedSpecName ~ 'Entity' ~ sprite.imageData.tiles.name }}Tiles,

	// pointer to the frames offsets
	{%- if sprite.imageData.tiles.frameOffsets is defined and sprite.imageData.tiles.frameOffsets.length %}
	(uint32*){{ tileName }}TilesFrameOffsets,
	{%- else %}
	NULL,
	{%- endif %}
};

{% endif -%}

TextureROMSpec {{ spriteName }}TextureSpec =
{
	// charset spec
	(CharSetSpec*)&{{ charsetSpecName }},

	// bgmap spec
	(uint16*){{ sanitizedSpecName ~ 'Entity' ~ sprite.imageData.maps[0].name }}Map,

	// cols (max 64)
	{{ sprite.imageData.maps[0].width }},

	// rows (max 64)
	{{ sprite.imageData.maps[0].height }},

	// padding for affine/hbias transformations
	{ {{ sprite.texture.padding.x }}, {{ sprite.texture.padding.y }} },

	// number of frames
	1,

	// palette number (0-3)
	{{ sprite.texture.palette }},

	// recyclable
	{{ sprite.texture.recycleable }},

	// vertical flip
	{{ sprite.texture.flip.vertical }},

	// horizontal flip
	{{ sprite.texture.flip.horizontal }},
};

{{ spriteClass }}ROMSpec {{ spriteName }}SpriteSpec =
{
	{
		// sprite's type
		__TYPE({{ spriteClass }}),

		// texture spec
		(TextureSpec*)&{{ spriteName }}TextureSpec,

		// transparency (__TRANSPARENCY_NONE, __TRANSPARENCY_EVEN or __TRANSPARENCY_ODD)
		__TRANSPARENCY_{{ sprite.transparency | upper }},

		// displacement
		{ {{ sprite.displacement.x }}, {{ sprite.displacement.y }}, {{ sprite.displacement.z }}, {{ sprite.displacement.parallax }} },
	},

	// bgmap mode (__WORLD_BGMAP, __WORLD_AFFINE, __WORLD_OBJECT or __WORLD_HBIAS)
	// make sure to use the proper corresponding sprite type throughout the spec ({{ spriteClass }} or ObjectSprite)
	{%- if item.sprites.type == 'Object' %}
	__WORLD_OBJECT,
	{%- else %}
	__WORLD_{{ sprite.bgmapMode | upper }},
	{% endif %}

	{%- if item.sprites.type != 'Object' %}
	// pointer to affine/hbias manipulation function
	{% if sprite.manipulationFunction %}(ParamTableEffectMethod){{ sprite.manipulationFunction }}{% else %}NULL{% endif %},
	{%- endif %}

	// display mode (__WORLD_ON, __WORLD_LON or __WORLD_RON)
	__WORLD_{{ sprite.displayMode }},
};

{% endfor -%}

{{ spriteClass }}ROMSpec* const {{ sanitizedSpecName }}SpriteSpecs[] =
{
	{% for spriteName in spriteNames -%}
	&{{ spriteName }}SpriteSpec,
	{% endfor -%}
	NULL
};
{%- endif %}

{#- PRINT ANIMATIONS -#}
{%- if item.animations.definitions.length -%}
{{ macros.sectionHeader('Animations') }}

{% for animation in item.animations.animations -%}
AnimationFunctionROMSpec {{ sanitizedSpecName }}{{ animation.name | toUpperSnakeCase }}Animation =
{
	// number of frames of this animation function
	{{ animation.frames.length }},

	// frames to play in animation
	{
		{{ animation.frames }}
	},

	// number of cycles a frame of animation is displayed
	{{ animation.cycles }},

	// whether to play it in loop or not
	{{ animation.loop }},

	// method to call on function completion
	{% if animation.callback %}(EventListener){{ animation.callback }}{% else %}NULL{% endif %},

	// function's name
	"{{ animation.name | sanitizeSpecName }}",
};

{% endfor -%}

AnimationFunctionROMSpec* const {{ sanitizedSpecName }}Animations =
{
	{% for animation in item.animations.definitions -%}
		(AnimationFunction*){{ sanitizedSpecName }}{{ animation.name | toUpperSnakeCase }}Animation,
	{% endfor -%}
	NULL
};
{% endif %}

{#- PRINT WIREFRAMES -#}
{%- if item.wireframes.wireframes.length %}


{{ macros.sectionHeader('Wireframes') }}

{% set wireframeNames = [] -%}
{%- for wireframe in item.wireframes.wireframes -%}
{%- set wireframeName = sanitizedSpecName ~ loop.index -%}
{%- set wireframeNames = (wireframeNames.push(wireframeName), wireframeNames) -%}

{% if wireframe.wireframe.type == 'Mesh' -%}
const PixelVector {{ wireframeName }}Segments[][2]=
{
	{%- for segment in wireframe.segments %}
	{
		{ {{ segment.fromVertex.x }}, {{ segment.fromVertex.y }}, {{ segment.fromVertex.z }}, {{ segment.fromVertex.parallax }} },
		{ {{ segment.toVertex.x }}, {{ segment.toVertex.y }}, {{ segment.toVertex.z }}, {{ segment.toVertex.parallax }} },
	},
	{%- endfor %}

	// limiter
	{
		{0, 0, 0, 0}, 
		{0, 0, 0, 0}
	},
};

{% endif -%}

{{ wireframe.wireframe.type }}ROMSpec {{ wireframeName }}WireframeSpec =
{
	{
		// class allocator
		__TYPE({{ wireframe.wireframe.type }}),

		// displacement
		{ {{ wireframe.wireframe.displacement.x }}, {{ wireframe.wireframe.displacement.yÂ }}, {{ wireframe.wireframe.displacement.z }}},
		
		// color
		{{ ['__COLOR_BLACK', '__COLOR_DARK_RED', '__COLOR_MEDIUM_RED', '__COLOR_BRIGHT_RED'][wireframe.wireframe.color] }},

		// transparent
		__TRANSPARENCY_{{ wireframe.wireframe.transparency | upper }},

		// interlaced
		{{ wireframe.wireframe.interlaced }},
	},

	{% if wireframe.wireframe.type == 'Sphere' -%}
	// radius
	__PIXELS_TO_METERS({{ wireframe.radius }}),

	// draw center
	{{ wireframe.drawCenter }},
	{%- elseif wireframe.wireframe.type == 'Mesh' -%}
	// segments
	(PixelVector(*)[2]){{ wireframeName }}Segments,
	{%- elseif wireframe.wireframe.type == 'Asterisk' -%}
	// length
	{{ wireframe.length }},
	{%- endif %}
};

{% endfor -%}

WireframeROMSpec* const {{ sanitizedSpecName }}WireframeSpecs[] =
{
	{% for wireframeName in wireframeNames -%}
	(WireframeSpec*)&{{ wireframeName }}WireframeSpec,
	{% endfor -%}
	NULL
};
{% endif %}

{#- PRINT COLLIDERS -#}
{%- if item.colliders.inGameType != 'None' and item.colliders.colliders.length %}

{{ macros.sectionHeader('Colliders') }}

ColliderROMSpecROMSpec {{ sanitizedSpecName }}ColliderSpecs =
{
	{% for collider in item.colliders.colliders -%}
	{
		// collider
		__TYPE({{ collider.type }}),

		// size (x, y, z)
		{ __F_TO_FIX7_9({{ collider.pixelSize.x }}), __F_TO_FIX7_9({{ collider.pixelSize.y }}), __F_TO_FIX7_9({{ collider.pixelSize.z }}) },

		// displacement (x, y, z, p)
		{ __F_TO_FIX7_9({{ collider.displacement.x }}), __F_TO_FIX7_9({{ collider.displacement.y }}), __F_TO_FIX7_9({{ collider.displacement.z }}), __F_TO_FIX7_9({{ collider.displacement.parallax }}) },

		// rotation (x, y, z)
		{ __F_TO_FIX7_9({{ collider.rotation.x }}), __F_TO_FIX7_9({{ collider.rotation.y }}), __F_TO_FIX7_9({{ collider.rotation.z }}) },

		// scale (x, y, z)
		{ __F_TO_FIX7_9({{ collider.scale.x }}), __F_TO_FIX7_9({{ collider.scale.y }}), __F_TO_FIX7_9({{ collider.scale.z }}) },

		// if true this collider checks for collisions against other shapes
		{{ collider.checkForCollisions }},

		// layers in which I live
		{%- if collider.layers.length > 0 %}
		kLayer{{ collider.layers.join(' | kLayer') }},
		{%- else %}
		kLayerNone,
		{%- endif %}

		// layers to ignore when checking for collisions
		{%- if collider.layersToCheck.length > 0 %}
		kLayerAll & ~(kLayer{{ collider.layersToCheck.join(' | kLayer') }})
		{%- else %}
		kLayerAll,
		{%- endif %}
	},
	{% endfor %}
	{NULL, {0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0}, {0, 0, 0}, false, kLayerNone, kLayerNone}
};
{% endif %}

{{ macros.sectionHeader('Entity') }}

{#- PRINT PHYSICAL PROPERTIES -#}
{% if item.physics.enabled %}

PhysicalPropertiesROMSpec {{ sanitizedSpecName }}PhysicalPropertiesSpec =
{
	// mass
	__F_TO_FIX10_6({{ item.physics.mass }}f),

	// friction
	__F_TO_FIX10_6({{ item.physics.friction }}f),

	// bounciness
	__F_TO_FIX10_6({{ item.physics.bounciness }}f),

	// maximum velocity
	{
		__I_TO_FIXED({{ item.physics.maximumVelocity.x }}), 
		__I_TO_FIXED({{ item.physics.maximumVelocity.y }}), 
		__I_TO_FIXED({{ item.physics.maximumVelocity.z }}),
	},

	// maximum speed
	__I_TO_FIXED({{ item.physics.maximumSpeed }})
};
{%- endif %}

{# PRINT ENTITY SPEC -#}
EntityROMSpec {{ sanitizedSpecName }}EntitySpec =
{
	// class allocator
	__TYPE(Entity),

	// children
	NULL,

	// behaviors
	NULL,

	// extra
	NULL,

	// sprites
	(SpriteSpec**){{ sanitizedSpecName }}SpriteSpecs,

	// use z displacement in projection
	false,

	// wireframes
	(WireframeSpec**)NULL,

	// collider shapes
	{%- if item.colliders.inGameType != 'None' and item.colliders.colliders.length %}
	(ColliderSpec*){{ sanitizedSpecName }}ColliderSpecs,
	{%- else %}
	NULL,
	{%- endif %}

	// size
	// if 0, width and height will be inferred from the first sprite's texture's size
	{
		{{ item.pixelSize.x }}, // x
		{{ item.pixelSize.y }}, // y
		{{ item.pixelSize.z }}, // z
	},

	// gameworld's character's type
	kType{{ item.colliders.inGameType | sanitizeSpecName }},

	// physical specification
	(PhysicalProperties*){%- if item.physics.enabled -%} 
			&{{ sanitizedSpecName }}PhysicalPropertiesSpec 
		{%- else -%} 
			NULL
		{%- endif -%},
};
