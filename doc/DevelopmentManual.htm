<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>VBJaEngine</title>
    <link href="assets/bootstrap/bootstrap.min.css" rel="stylesheet">
    <link href="assets/bootstrap/bootstrap-theme.min.css" rel="stylesheet">
    <link href="assets/custom/style.css" rel="stylesheet">
    <link href="assets/prism/prism.css" rel="stylesheet" />
    <link rel="icon" href="assets/favicon.ico">

    <!--[if lt IE 9]>
    <script src="assets/ie/html5shiv.min.js"></script>
    <script src="assets/ie/respond.min.js"></script>
    <![endif]-->

</head>
<body>

<div class="abstract">
    <div class="container">
        <h1>// VBJaEngine Development Manual</h1>
        The VBJaEngine has been developed to fill the gap between the developer's game logic and the
        hardware management required to produce visual and audio results on the Nintendo Virtual Boy. The
        engine is a sprite based engine, which takes care of all the work necessary to display user defined
        sprite images on screen, allocating graphical and CPU's memory to hold the definitions of such
        images.
    </div>
</div>

<div class="container">

    <div class="row">
        <div class="col-md-9 documentation" role="main">


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Overview</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Features</h3>

            <p>
                The engine provides the following features for the programmer to take advantage of:
            </p>

            <ul>
                <li>Automatic Char memory allocation</li>
                <li>Automatic BGMap memory allocation</li>
                <li>Automatic world layer assignment based on the object's Z position</li>
                <li>Automatic frame rate control</li>
                <li>Memory Pool to allocate memory dynamically</li>
                <li>Automatic memory allocation for Param tables (used in Affine and H-Bias modes)</li>
                <li>Easy to use printing functions to facilitate debug</li>
                <li>Sound reproduction of one BGM and up to two FX sounds simultaneously</li>
                <li>A generic container</li>
                <li>Messaging system</li>
                <li>Generic State Machine</li>
                <li>Automatic collision detection and notification</li>
                <li>Object Oriented support through the use of Metaprogramming (C MACROS):
                    <ul>
                        <li>Inheritance</li>
                        <li>Polymorphism</li>
                        <li>Encapsulation</li>
                    </ul>
                </li>
                <li>Useful classes to speed up the content creation process:
                    <ul>
                        <li>Image</li>
                        <li>Background</li>
                        <li>Character</li>
                        <li>Scroll</li>
                    </ul>
                </li>
                <li>Automatic loading/unloading of objects in/outside the screen</li>
                <li>3D stages</li>
                <li>Simple physics simulation:
                    <ul>
                        <li>Accelerated/uniform movement.</li>
                        <li>Gravity</li>
                        <li>Friction</li>
                        <li>Scaling/rotation effects.</li>
                    </ul>
                </li>
                <li>Clocking system</li>
                <li>Automatic projection/parallax/scale calculation and rendering</li>
                <li>Customizable perspective/deep effects on real time</li>
                <li>Frame based animation system with callback support</li>
                <li>Generic main game algorithm (game loop)</li>
            </ul>

            <h4>TODO</h4>

            <ul>
                <li>Particle system</li>
                <li>Polygon based engine</li>
                <li>Tile based collision detection</li>
            </ul>

            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Object Oriented Programming</h2>

            <p>
                Since the nature of games is better and more easily represented by the OOP paradigm than a
                structured one, because the former allows for better code re-usage and flexibility, and since the
                available compiler for the VB only supports C, for this engine a set of C MACROS have been created
                to simulate some of the most visible features provided by C++:
            </p>
            <ul>
                <li>Inheritance</li>
                <li>Polymorphism</li>
                <li>Encapsulation</li>
            </ul>
            <p>
                In order to use these features, you must be comfortable using some MACRO calls which will be
                explained next.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Creating a Class</h3>

            <p>
                Every class in the engine and the game must inherit from a base class called Object or from another
                class which inherits from it.
            </p>

            <p>
                Let's create a Hero class which inherits from the Character class provided with the engine. In the
                header file Hero.h the following macros must be placed. This will allow the Hero class to inherit the
                virtual methods from the Character class.
            </p>

            <pre class="line-numbers"><code class="language-c">#define Hero_METHODS								        \
Character_METHODS;</code></pre>

            <p>
                Next, it is necessary to inherit and/or redefine those method's definitions.
            </p>

            <pre class="line-numbers"><code class="language-c">#define Hero_SET_VTABLE(ClassName)						\
Character_SET_VTABLE(ClassName);						\
__VIRTUAL_SET(ClassName, Hero, die);</code></pre>

            <p>
                This tells the engine that Character has a virtual method called <code>die</code>
                (<code>Character_die</code> actually) and we want to redefine that method with our own version of
                <code>die</code>, thus allowing <i>Polymorphism</i>.
            </p>

            <p>
                Then you must declare the class with the following line:
            </p>

            <pre class="line-numbers"><code class="language-c">__CLASS(Hero);</code></pre>

            <p>
                This will define a pointer Hero to a struct, this way the Hero class's implementation is hidden from
                client code, making it impossible to access private members, which provides <i>Encapsulation</i>.
            </p>

            <p>
                Then you must declare Hero class's specific attributes, to do so, declare the following MACRO:
            </p>

            <pre class="line-numbers"><code class="language-c">#define Hero_ATTRIBUTES						        	\
                                                        \
/* it is derivated from */					    		\
Character_ATTRIBUTES							    	\
                                                        \
/* hero has energy	*/							        \
u8 energy;</code></pre>

            <p>
                Notice that all of these macros have a backslash ("\") at the end of each line, you must be careful and
                always be sure that there are not blank or tab spaces after them. The reason to declare the class's
                attributes this way is because this allows to inherit methods/attributes, and at the same time allows to
                make the attributes private. Notice that in order for Hero to inherit Character's attributes it includes
                in <code>Hero_ATTRIBUTES</code> the <code>Character_ATTRIBUTES</code>.
            </p>

            <p>
                The last thing to be done in the header file is to declare the next methods:
            </p>

            <p>
                <strong>Allocator:</strong> all classes must follow the following format (the arguments are optional).
            </p>
            <pre class="line-numbers"><code class="language-c">Hero Hero_new(CharacterDefinition* animatedEntityDefinition, int ID);</code></pre>

            <p>
                <strong>Constructor:</strong> the first argument is mandatory.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_constructor(Hero this, CharacterDefinition* definition, int ID);</code></pre>

            <p>
                <strong>Destructor:</strong> the argument is mandatory and must only be one in all cases.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_destructor(Hero this);</code></pre>

            <p>
                Now it is time to define the class. In the source file Hero.c do as follows.
                Include the header file which holds the class's declaration:
            </p>

            <pre class="line-numbers"><code class="language-c">#include "Hero.h"</code></pre>

            <p>
                Define the class:
            </p>

            <pre class="line-numbers"><code class="language-c">// A Hero! Which inherits from Character
__CLASS_DEFINITION(Hero, Character);</code></pre>

            <p>
                Define the allocator:
            </p>

            <pre class="line-numbers"><code class="language-c">// always call these to macros next to each other
__CLASS_NEW_DEFINITION(Hero, __PARAMETERS(CharacterDefinition* characterDefinition, int ID))
__CLASS_NEW_END(Hero, __ARGUMENTS(this, characterDefinition, ID));</code></pre>

            <p>
                Define the constructor: must always call the parent class's constructor to properly initialize the object.
            </p>

            <pre class="line-numbers"><code class="language-c">// class's constructor
    void Hero_constructor(Hero this, CharacterDefinition* characterDefinition, int ID){

    __CONSTRUCT_BASE(Character, __ARGUMENTS(this, characterDefinition, ID));

    this->energy = 1;

    ...

} </code></pre>

            <p>
                Define the destructor: must always destroy the parent class at the end of the method.
            </p>

            <pre class="line-numbers"><code class="language-c">// class's destructor
    void Hero_destructor(Hero this){

    // free space allocated here

    // delete the super object
    __DEALLOCATE(Character);
} </code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Virtual Calls</h3>

            <p>
                The purpose of having OOP features is to allow generic programming through the use of virtual calls
                to class methods through a base class pointer. For example, the Stage has a list of Entities (from
                which Character, Background and Image inherit) and it must be able to call the proper update and
                render methods on those classes. To do so, there are two possible ways:
            </p>

            <ol>
                <li>
                    Using a switch statement to determine which type of object is being pointed to by the parent
                    class pointer, which can mean having to store extra info on each object to hold the type, and
                    can be quite cumbersome if we extend to have more kind of Entities.
                </li>
                <li>
                    The other way is to use virtual calls to virtual methods, as shown below:
                </li>
            </ol>

            <pre class="line-numbers"><code class="language-c">// update each entity's internal state
void Stage_update(Stage this)
{
    VirtualNode node = VirtualList_begin(this->entities);

    for(; node ; node = VirtualNode_getNext(node)) {
        __VIRTUAL_CALL(void, Entity, update,(Entity)VirtualNode_getData(node));
    }
} </code></pre>

            <p>
                As you can see, there is only one call to the method, which depends on the type of object that is currently being processed.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Abstract classes</h3>

            <p>
                To define an abstract class, simply omit the <code>__VIRTUAL_SET</code> definition.
            </p>

            <p>
                Trying to instantiate an abstract Entity will result in an exception in <code>__DEBUG</code> mode.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>The Game's StateMachine</h2>

            <p>
                The Game itself has a StateMachine to hold the actual state of it and execute the proper logic. So
                after creating the game, and before entering the game's infinite loop, it must enter a valid state:
            </p>

            <pre class="line-numbers"><code class="language-c">// Main game algorithm
// There should not be need
// to modify this.

int main(void){

// create the game
Game game = Game_getInstance();

// clear sprite memory
vbClearScreen();

// turn on the display
vbDisplayOn();

// set engine's initial state
Game_setState(game, (State)PVBCCScreen_getInstance());

// main game loop
Game_update (game);

// end program
return true;
} </code></pre>

            <p>
                As you can see, the game will enter the state PVBCCScreen first, and then will enter the game's main loop Game_update();
                PVBCCScreen is a game state which must perform and initialization, execute its logic, and change the game's current state to another one based on user input.
            </p>
            <p>
                In its initialization stage, PVBCCScreen loads a GameWorld definition which describes the Stage, and the Entities within it:
            </p>

            <pre class="line-numbers"><code class="language-c">// state's enter
static void PVBCCScreen_enter(PVBCCScreen this, void* owner){

//clear char and bgmap memory
vbClearScreen();

// reset the engine state
Game_reset(Game_getInstance(), true);

// load world's entities
Stage_setup(Game_getStage(Game_getInstance()), &PVBCC_WR);

// call the render to setup world entries
Game_render(Game_getInstance());

// make a fade in
Game_FXFadeIn(Game_getInstance(), FADEDELAY);
}</code></pre>

            <p>
                The Stage_setup method instructs the stage to load the world defined by PVBCC_WR.
            </p>

            <pre class="line-numbers"><code class="language-c">StageDefinition PVBCC_WR = {
// size
{
    // x
    384,
    // y
    228,
    // z
    10
},
//initial screen position
{
    // x
    0,
    // y
    0,
    //z
    __ZZERO
},
//background music
    NULL,

//entities
{
    {&PVBCC_LEFT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
    {&PVBCC_RIGHT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
    {NULL, {0,0,0}},
},
};</code></pre>

            <p>
                A Stage is defined by its size, the initial screen position, a pointer to a BGM, and a list of Entities. There must be always a {NULL, {0,0,0}} at the end of the definition to inform the Stage that the Entity list ends there.
            </p>
            <p>
                Let's take a look at one of the Entities being loaded.
            </p>

            <pre class="line-numbers"><code class="language-c">ImageDefinition PVBCC_LEFT_BG = {
    {
        // object's class
        __TYPE(Image),

        // Sprite
        {
            // the texture
            &PVBCC_LEFT_TX,

            // bgmap mode ( BGMAP, AFFINE, H-BIAS)
            WRLD_BGMAP,

            // display mode
            WRLD_LON,
        },
    },
};</code></pre>

            <p>
                The following line tells the Stage which kind of Entity is currently being loaded so the proper constructor is called.
            </p>

            <pre class="line-numbers"><code class="language-c">__TYPE(Image)</code></pre>

            <p>
                Then comes the Sprite definition, PVBCC_LEFT_TX is the address of the Texture to use with the Sprite. The Sprite definition dictates the texture display mode (affine, bgmap, h-bias) and the displays on which the image will be shown.
            </p>

            <pre class="line-numbers"><code class="language-c">TextureDefinition PVBCC_LEFT_TX = {

    // Chargroup
    {
        // chDefinition,
        PVBCC_CHARSET_LEFT,

        // numChars,
        238,

        // allocation type
        __NO_ANIMATED
    },

    // bgmap definition
    PVBCC_MAP_LEFT,

    // cols (max 48)
    48,

    // rows (max 28)
    28,

    //pallet number,
    0
}; </code></pre>

            <p>
                PVBCC_CHARSET_LEFT and PVBCC_MAP_LEFT are the names of the const arrays with the char and bgmap definitions produced by programs like VIDE.
            </p>
            <p>
                Notice that the total cols and rows which represent the image's size, are 8's divisors since each char is 8 pixels wide and 8 pixels height.
            </p>

            <!--------------------------------------------------------------------------------------------------------->

            <h2>Creating Animations</h2>

            <p>
                Characters are used to represent Entities which have certain animations and which can move inside the Stage. In order to provide a Character with an animation it must be defined as follow:
            </p>
            <pre class="line-numbers"><code class="language-c">CharacterDefinition HERO_MC = {
    {
        {
            // object's class
            __TYPE(Hero),

            // Sprite
            {
                // the texture
                &HERO_TX,

                // bgmap mode ( BGMAP, AFFINE, H-BIAS)
                WRLD_AFFINE,

                // display mode
                WRLD_ON,
            },
        },

        // deep
        5,

        // friction factor
        5.5,

        //collision detection gap
        //up,	down,	left,	right,
        {5,		0,		8,		6,},

        // in game type
        kHero,
    },

    // pointer to the animation definition for the character
    &HERO_ANIM,
};

// a function which defines the frames to play
AnimationFunction HERO_BLINKING_ANIM = {

    // function's name
    "Blink",

    // number of frames of this animation function
    3,

    // frames to play in animation
    {16, 17, 16},

    // number of cicles a frame of animation is displayed
    5 * __FPS_ANIM_FACTOR,

    // whether to play it in loop or not
    false,

    // method to call function completion
    Hero_blinkDone,
};

// an animation definition
AnimationDescription HERO_ANIM = {

    // number of animation frames
    28,

    // animation functions
    {
        &HERO_IDLE_ANIM,
        &HERO_WALKING_ANIM,
        &HERO_JUMPING_ANIM,
        &HERO_FALLING_ANIM,
        &HERO_SLIDING_ANIM,
        &HERO_HIT_FRONT_ANIM,
        &HERO_HIT_BEHIND_ANIM,
        &HERO_JUMP_BACK_ANIM,
        &HERO_JUMP_FRONT_ANIM,
        &HERO_FRONT_ANIM,
        &HERO_BACK_ANIM,
        &HERO_BLINKING_ANIM,
        &HERO_WALKING_HOLD_ANIM,
        &HERO_BLINKING_HOLD_ANIM,
        &HERO_IDLE_HOLD_ANIM,
        &HERO_JUMPING_HOLD_ANIM,
        &HERO_FALLING_HOLD_ANIM,
        &HERO_WALKING_FRONT_ANIM,
        &HERO_WALKING_BACK_ANIM,
        NULL,
    }

}; </code></pre>

            <p>
                The AnimationDescription defines how many animation frames comprise the animation, and holds the address of each AnimationFunction. An AnimationFunction must provide a name, the number of frames to be played, the sequence of frames, each frame duration based on the target frame rate, whether the frames must be played in a loop, and a function pointer to be called when the last frame of animation has been displayed.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Animation allocation types</h3>

            <p>
                Since there can be Characters with many frames of animations like Hero, and Characters with simple animations like Koopas, there is a need to allocate each kind in different ways.
            </p>
            <p>
                There are three ways to allocate animations in memory:
            </p>
            <pre><code class="language-c">__ANIMATED:</code></pre>
            <p>
                Each Character has its dedicated char and bgmap memory. On each animation frame change, the char definition is rewritten with the next. Use this method for character with tons of animations.
            </p>
            <pre><code class="language-c">__ANIMATED_SHARED:</code></pre>
            <p>
                Each Character has its dedicated char and bgmap memory. On each animation frame change, the char definition is rewritten with the next. Use this method for character with tons of animations.
            </p>
            <pre><code class="language-c">__NO_ANIMATED:</code></pre>
            <p>
                Used with static images like backgrounds, logos, etc.
            </p>
            <p>
                In order to play a specific animation, call the following method:
            </p>
            <pre><code class="language-c">Character_playAnimation((Character)this, "Blink");</code></pre>
            <p>
                Or directly:
            </p>
            <pre><code class="language-c">AnimatedSprite_play((AnimatedSprite)this->sprite, this->characterDefinition->animationDescription, animationName); </code></pre>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>The Stage</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Adding objects to the Stage</h3>

            <p>
                To add objects to the Stage call the following method:
            </p>

            <pre class="line-numbers"><code class="language-c">// create an entity in the game's and load it into the Stage
                Hero hero = Stage_addEntity(Game_getStage(Game_getInstance(),heroDefinition, position, -1); </code></pre>

            <p>
                Notice the -1, that is the Entity's ID, the Stage will assign valid IDs to Entities loaded from a
                GameWorld definition, when you want to create a dynamic Entity (i.e: a Hero's fireball) provide the -1
                index. This method will do the necessary calls to allocate the object in CPU and graphic memory, add it
                to the stage and assign a world layer to be displayed.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Removing objects from the Stage</h3>

            <p>
                Let say our Hero character has been killed and must now to be removed from the Stage, to do so call the
                following method:
            </p>

            <pre class="line-numbers"><code class="language-c">// inform the game that I'm dead
                Stage_removeEntity(Game_getStage(Game_getInstance()), (Entity)hero, kDead); </code></pre>

            <p>
                Notice the kDead enum, which tells the engine to not load the Entity again if it is within the screen range.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Internationalization</h2>

            The Internationalization ("I18n") module allows you to add multiple selectable languages to your project.


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Defining strings</h3>

            <p>
                Create an enum that defines all translatable strings that are in the game.
            </p>

            <pre class="line-numbers"><code class="language-c">enum {
    STR_HELLO,
    STR_VBJAENGINE_ROCKS
};</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Languages files</h3>

            <p>
                For each language, define an array of strings. Make sure to keep the string order as defined in the enum
                above. You'll want to create one file per language definition.
                Ensure these files are encoded in ANSI for special characters ("umlauts") to work.
            </p>

            <p>
                The following gives an example for an English language definition file.
            </p>

            <pre class="line-numbers"><code class="language-c">static char* Lang_EN[] = {

    // STR_HELLO
    "Hello",

    // STR_VBJAENGINE_ROCKS
    "The VBJaEngine rocks!",

};</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Registering languages</h3>

            <p>
                During the initialization phase of your game, inform the engine about available languages by registering
                each one using the <code>I18n_registerLanguage</code> method.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_registerLanguage(I18n_getInstance(), Lang_EN);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Setting active language</h3>

            <p>
                You can set the active language using the <code>I18n_setLanguage</code> method. Each registered language
                is identified by an integer in the order they were registered, starting with 0. By default, the first
                registered language is used.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setLanguage(I18n_getInstance(), 0);</code></pre>

            <p>
                For easier identification of your registered languages, you'll want to creating an enum with string
                identificators in the same order you register the languages with the engine. For example:
            </p>

            <pre class="line-numbers"><code class="language-c">enum {
    LANGUAGE_EN,
    LANGUAGE_DE
};</code></pre>

            <p>
                If you made languages accessible through these, a call to change the language to German would look like
                the following.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setLanguage(I18n_getInstance(), LANGUAGE_DE);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Getting a translated string</h3>

            <p>
                The <code>I18n_getText</code> method retrieves a string by a given identifier in the currently active
                language.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_getText(I18n_getInstance(), STR_HELLO)</code></pre>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

        </div>

        <div class="col-md-3">
            <div class="sidebar hidden-print hidden-xs hidden-sm" role="complementary">
                <ul class="nav" id="jae-sidebar-toc">
                </ul>
            </div>
        </div>

    </div>
</div>

<footer role="contentinfo">
    <div class="container">
        <p>
            This document was last modified on <span id="footerLastModified"> </span>
            <script type="text/javascript">
                document.getElementById("footerLastModified").innerHTML = document.lastModified;
            </script>
        </p>
        <p>
            The VBJaEngine was written by Jorge Eremiev &lt;<a href="mailto:jorgech3@gmail.com">jorgech3@gmail.com</a>&gt;
        </p>
        <p>
            Copyright &copy; 2007, 2014
        </p>
        <ul class="footer-links muted">
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine" target="_blank">Bitbucket</a></li>
            <li>&middot;</li>
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine-skeleton" target="_blank">Skeleton</a></li>
            <li>&middot;</li>
            <li><a href="http://www.planetvb.com" target="_blank">Planet Virtual Boy</a></li>
        </ul>
    </div>
</footer>

<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/bootstrap.min.js"></script>
<script src="assets/prism/prism.js"></script>
<script src="assets/custom/script.js"></script>
<script src="assets/custom/create-toc.js"></script>
<script src="assets/custom/smooth-scroll.js"></script>
<script src="assets/ie/ie10-viewport-bug-workaround.js"></script>

</body>
</html>
