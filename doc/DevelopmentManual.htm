<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>VBJaEngine</title>
    <link href="assets/bootstrap/bootstrap.min.css" rel="stylesheet">
    <link href="assets/bootstrap/bootstrap-theme.min.css" rel="stylesheet">
    <link href="assets/custom/style.css" rel="stylesheet">
    <link href="assets/prism/prism.css" rel="stylesheet" />
    <link rel="icon" href="assets/favicon.ico">

    <!--[if lt IE 9]>
    <script src="assets/ie/html5shiv.min.js"></script>
    <script src="assets/ie/respond.min.js"></script>
    <![endif]-->

</head>
<body>

<div class="abstract">
    <div class="container">
        <h1>// VBJaEngine Development Manual</h1>
        The VBJaEngine has been developed to fill the gap between the developer's game logic and the
        hardware management required to produce visual and audio results on the Nintendo Virtual Boy. The
        engine is a sprite based engine, which takes care of all the work necessary to display user defined
        sprite images on screen, allocating graphical and CPU's memory to hold the definitions of such
        images.
    </div>
</div>

<div class="container">

    <div class="row">
        <div class="col-md-9 documentation" role="main">


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Overview</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Features</h3>

            <p>
                The engine provides the following features for the programmer to take advantage of:
            </p>

            <ul>
                <li>Automatic Char memory allocation</li>
                <li>Automatic BGMap memory allocation</li>
                <li>Automatic world layer assignment based on the object's Z position</li>
                <li>Automatic frame rate control</li>
                <li>Memory Pool to allocate memory dynamically</li>
                <li>Automatic memory allocation for Param tables (used in Affine and H-Bias modes)</li>
                <li>Easy to use printing functions to facilitate debug</li>
                <li>Sound reproduction of one BGM and up to two FX sounds simultaneously</li>
                <li>A generic container</li>
                <li>Messaging system</li>
                <li>Generic State Machine</li>
                <li>Automatic collision detection and notification</li>
                <li>Object Oriented support through the use of Metaprogramming (C MACROS):
                    <ul>
                        <li>Inheritance</li>
                        <li>Polymorphism</li>
                        <li>Encapsulation</li>
                    </ul>
                </li>
                <li>Useful classes to speed up the content creation process:
                    <ul>
                        <li>Image</li>
                        <li>Background</li>
                        <li>Character</li>
                        <li>Scroll</li>
                    </ul>
                </li>
                <li>Automatic loading/unloading of objects in/outside the screen</li>
                <li>3D stages</li>
                <li>Simple physics simulation:
                    <ul>
                        <li>Accelerated/uniform movement.</li>
                        <li>Gravity</li>
                        <li>Friction</li>
                        <li>Scaling/rotation effects.</li>
                    </ul>
                </li>
                <li>Clocking system</li>
                <li>Automatic projection/parallax/scale calculation and rendering</li>
                <li>Customizable perspective/deep effects on real time</li>
                <li>Frame based animation system with callback support</li>
                <li>Generic main game algorithm (game loop)</li>
            </ul>

            <h4>TODO</h4>

            <ul>
                <li>Particle system</li>
                <li>Polygon based engine</li>
                <li>Tile based collision detection</li>
                <li>BGMAP defragmentation<li>
                <li>More collision shapes: spheres, complex polyhedrons, etc.</li>
                <li>Object based entities (instead of Texture based as they currently are)</li>

            </ul>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Object Oriented Programming</h2>

            <p>
                Since the nature of games is better and more easily represented by the OOP paradigm than a
                structured one, because the former allows for better code re-usage and flexibility, and since the
                available compiler for the VB only supports C, for this engine a set of C MACROS have been created
                to simulate some of the most visible features provided by C++:
            </p>
            <ul>
                <li>Inheritance</li>
                <li>Polymorphism</li>
                <li>Encapsulation</li>
            </ul>
            <p>
                In order to use these features, you must be comfortable using some MACRO calls which will be
                explained next.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Creating a Class</h3>

            <p>
                Every class in the engine and the game must inherit from a base class called Object or from another
                class which inherits from it.
            </p>

            <p>
                Let's create a Hero class which inherits from the Character class provided with the engine. In the
                header file Hero.h the following macros must be placed. This will allow the Hero class to inherit the
                virtual methods from the Character class.
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_METHODS								        \
                    Character_METHODS;</code></pre>

            <p>
                Next, it is necessary to inherit and/or redefine those method's definitions.
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_SET_VTABLE(ClassName)						\
                    Character_SET_VTABLE(ClassName);						\
                    __VIRTUAL_SET(ClassName, Hero, die);</code></pre>

            <p>
                This tells the engine that Character has a virtual method called <code>die</code>
                (<code>Character_die</code> actually) and we want to redefine that method with our own version of
                <code>die</code>, thus allowing <i>Polymorphism</i>.
            </p>

            <p>
                Then you must declare the class with the following line:
            </p>

            <pre class="line-numbers"><code class="language-c">__CLASS(Hero);</code></pre>

            <p>
                This will define a pointer Hero to a struct, this way the Hero class's implementation is hidden from
                client code, making it impossible to access private members, which provides <i>Encapsulation</i>.
            </p>

            <p>
                Then you must declare Hero class's specific attributes, to do so, declare the following MACRO:
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_ATTRIBUTES						        	\
                    \
                    /* it is derivated from */					    		\
                    Character_ATTRIBUTES							    	\
                    \
                    /* hero has energy	*/							        \
                    u8 energy;</code></pre>

            <p>
                Notice that all of these macros have a backslash ("\") at the end of each line, you must be careful and
                always be sure that there are not blank or tab spaces after them. The reason to declare the class's
                attributes this way is because this allows to inherit methods/attributes, and at the same time allows to
                make the attributes private. Notice that in order for Hero to inherit Character's attributes it includes
                in <code>Hero_ATTRIBUTES</code> the <code>Character_ATTRIBUTES</code>.
            </p>

            <p>
                The last thing to be done in the header file is to declare the next methods:
            </p>

            <p>
                <strong>Allocator:</strong> all classes must follow the following format (the arguments are optional).
            </p>
            <pre class="line-numbers"><code class="language-c">Hero Hero_new(CharacterDefinition* animatedEntityDefinition, int ID);</code></pre>

            <p>
                <strong>Constructor:</strong> the first argument is mandatory.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_constructor(Hero this, CharacterDefinition* definition, int ID);</code></pre>

            <p>
                <strong>Destructor:</strong> the argument is mandatory and must only be one in all cases.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_destructor(Hero this);</code></pre>

            <p>
                Now it is time to define the class. In the source file Hero.c do as follows.
                Include the header file which holds the class's declaration:
            </p>

            <pre class="line-numbers"><code class="language-c">#include "Hero.h"</code></pre>

            <p>
                Define the class:
            </p>

                <pre class="line-numbers"><code class="language-c">// A Hero! Which inherits from Character
                    __CLASS_DEFINITION(Hero, Character);</code></pre>

            <p>
                Define the allocator:
            </p>

                <pre class="line-numbers"><code class="language-c">// always call these to macros next to each other
                    __CLASS_NEW_DEFINITION(Hero, __PARAMETERS(CharacterDefinition* characterDefinition, int ID))
                    __CLASS_NEW_END(Hero, __ARGUMENTS(this, characterDefinition, ID));</code></pre>

            <p>
                Define the constructor: must always call the parent class's constructor to properly initialize the object.
            </p>

                <pre class="line-numbers"><code class="language-c">// class's constructor
                    void Hero_constructor(Hero this, CharacterDefinition* characterDefinition, int ID){

                    __CONSTRUCT_BASE(Character, __ARGUMENTS(this, characterDefinition, ID));

                    this->energy = 1;

                    ...

                    } </code></pre>

            <p>
                Define the destructor: must always destroy the parent class at the end of the method.
            </p>

                <pre class="line-numbers"><code class="language-c">// class's destructor
                    void Hero_destructor(Hero this){

                    // free space allocated here

                    // delete the super object
                    __DEALLOCATE(Character);
                    } </code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Virtual Calls</h3>

            <p>
                The purpose of having OOP features is to allow generic programming through the use of virtual calls
                to class methods through a base class pointer. For example, the Stage has a list of Entities (from
                which Character, Background and Image inherit) and it must be able to call the proper update and
                render methods on those classes. To do so, there are two possible ways:
            </p>

            <ol>
                <li>
                    Using a switch statement to determine which type of object is being pointed to by the parent
                    class pointer, which can mean having to store extra info on each object to hold the type, and
                    can be quite cumbersome if we extend to have more kind of Entities.
                </li>
                <li>
                    The other way is to use virtual calls to virtual methods, as shown below:
                </li>
            </ol>

                <pre class="line-numbers"><code class="language-c">// update each entity's internal state
                    void Stage_update(Stage this)
                    {
                    VirtualNode node = VirtualList_begin(this->entities);

                    for(; node ; node = VirtualNode_getNext(node)) {
                    __VIRTUAL_CALL(void, Entity, update,(Entity)VirtualNode_getData(node));
                    }
                    } </code></pre>

            <p>
                As you can see, there is only one call to the method, which depends on the type of object that is currently being processed.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Abstract classes</h3>

            <p>
                To define an abstract class, simply omit the <code>__VIRTUAL_SET</code> definition.
            </p>

            <p>
                Trying to instantiate an abstract Entity will result in an exception in <code>__DEBUG</code> mode.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Singletons</h3>

            <p>
                [[TODO]]
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Graphics</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>2D</h3>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>AnimatedSprite</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>Animation allocation types</h5>

            <p>
                Since there can be Characters with many frames of animations like Hero, and Characters with simple animations like Koopas, there is a need to allocate each kind in different ways.
            </p>
            <p>
                There are three ways to allocate animations in memory:
            </p>
            <pre><code class="language-c">__ANIMATED:</code></pre>
            <p>
                Each Character has its dedicated char and bgmap memory. On each animation frame change, the char definition is rewritten with the next. Use this method for character with tons of animations.
            </p>
            <pre><code class="language-c">__ANIMATED_SHARED:</code></pre>
            <p>
                Each Character has its dedicated char and bgmap memory. On each animation frame change, the char definition is rewritten with the next. Use this method for character with tons of animations.
            </p>
            <pre><code class="language-c">__NO_ANIMATED:</code></pre>
            <p>
                Used with static images like backgrounds, logos, etc.
            </p>
            <p>
                In order to play a specific animation, call the following method:
            </p>
            <pre><code class="language-c">Character_playAnimation((Character)this, "Blink");</code></pre>
            <p>
                Or directly:
            </p>
            <pre><code class="language-c">AnimatedSprite_play((AnimatedSprite)this->sprite, this->characterDefinition->animationDescription, animationName); </code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>Sprite</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>Sprite</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>MSprite</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>SpriteManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>ParamTable</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>ParamTableManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>Texture</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>TextureManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>3D</h3>

            <p>[not yet implemented]</p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->


            <h2>In-game object types</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Container</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Entity</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>InGameEntity</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>AnimatedInGameEntity</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Actor</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>InanimatedInGameEntity</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Image</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>MBackground</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Stage</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Streaming</h3>
                - Constructing a Stage: Here we have to address the PositionedEntity struct in detail, specially the extra info attribute which must only be used in "final" classes.


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Physics</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>PhysicalWorld</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Body</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Mass</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Collisions</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Shape</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Cuboid</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Circle</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Object interaction</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Messaging</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Event System</h3>
                - There is an event propagation capability in the engine, indeed, I could combine this with the event system, and we would get the full bubbling event capabilities of languages like ActionScript... at least as far as I remember :P


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>State Machine</h2>

            <p>
                The Game itself has a StateMachine to hold the actual state of it and execute the proper logic. So
                after creating the game, and before entering the game's infinite loop, it must enter a valid state:
            </p>

            <pre class="line-numbers"><code class="language-c">// Main game algorithm
                // There should not be need
                // to modify this.

                int main(void){

                // create the game
                Game game = Game_getInstance();

                // clear sprite memory
                vbClearScreen();

                // turn on the display
                vbDisplayOn();

                // set engine's initial state
                Game_setState(game, (State)PVBCCScreen_getInstance());

                // main game loop
                Game_update (game);

                // end program
                return true;
                } </code></pre>

            <p>
                As you can see, the game will enter the state PVBCCScreen first, and then will enter the game's main loop Game_update();
                PVBCCScreen is a game state which must perform and initialization, execute its logic, and change the game's current state to another one based on user input.
            </p>
            <p>
                In its initialization stage, PVBCCScreen loads a GameWorld definition which describes the Stage, and the Entities within it:
            </p>

            <pre class="line-numbers"><code class="language-c">// state's enter
                static void PVBCCScreen_enter(PVBCCScreen this, void* owner){

                //clear char and bgmap memory
                vbClearScreen();

                // reset the engine state
                Game_reset(Game_getInstance(), true);

                // load world's entities
                Stage_setup(Game_getStage(Game_getInstance()), &PVBCC_WR);

                // call the render to setup world entries
                Game_render(Game_getInstance());

                // make a fade in
                Game_FXFadeIn(Game_getInstance(), FADEDELAY);
                }</code></pre>

            <p>
                The Stage_setup method instructs the stage to load the world defined by PVBCC_WR.
            </p>

            <pre class="line-numbers"><code class="language-c">StageDefinition PVBCC_WR =
                {
                // size
                {
                // x
                384,
                // y
                228,
                // z
                10
                },
                //initial screen position
                {
                // x
                0,
                // y
                0,
                //z
                __ZZERO
                },
                //background music
                NULL,

                //entities
                {
                {&PVBCC_LEFT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
                {&PVBCC_RIGHT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
                {NULL, {0,0,0}},
                },
                };</code></pre>

            <p>
                A Stage is defined by its size, the initial screen position, a pointer to a BGM, and a list of Entities. There must be always a {NULL, {0,0,0}} at the end of the definition to inform the Stage that the Entity list ends there.
            </p>
            <p>
                Let's take a look at one of the Entities being loaded.
            </p>

            <pre class="line-numbers"><code class="language-c">ImageDefinition PVBCC_LEFT_BG =
                {
                {
                // object's class
                __TYPE(Image),

                // Sprite
                {
                // the texture
                &PVBCC_LEFT_TX,

                // bgmap mode ( BGMAP, AFFINE, H-BIAS)
                WRLD_BGMAP,

                // display mode
                WRLD_LON,
                },
                },
                };</code></pre>

            <p>
                The following line tells the Stage which kind of Entity is currently being loaded so the proper constructor is called.
            </p>

            <pre class="line-numbers"><code class="language-c">__TYPE(Image)</code></pre>

            <p>
                Then comes the Sprite definition, PVBCC_LEFT_TX is the address of the Texture to use with the Sprite. The Sprite definition dictates the texture display mode (affine, bgmap, h-bias) and the displays on which the image will be shown.
            </p>

            <pre class="line-numbers"><code class="language-c">TextureDefinition PVBCC_LEFT_TX =
                {

                // CharSet
                {
                // chDefinition,
                PVBCC_CHARSET_LEFT,

                // numChars,
                238,

                // allocation type
                __NO_ANIMATED
                },

                // bgmap definition
                PVBCC_MAP_LEFT,

                // cols (max 48)
                48,

                // rows (max 28)
                28,

                //palette number,
                0
                }; </code></pre>

            <p>
                PVBCC_CHARSET_LEFT and PVBCC_MAP_LEFT are the names of the const arrays with the char and bgmap definitions produced by programs like VIDE.
            </p>
            <p>
                Notice that the total cols and rows which represent the image's size, are 8's divisors since each char is 8 pixels wide and 8 pixels height.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>In-game clock</h2>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Hardware</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Memory Pool</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>HardwareManager</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Keypad</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Timers</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VIP</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VPU</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>SaveRAM</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Link Cable</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Sound</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Printing</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>The printing layer</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Font management</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Internationalization</h2>

            The Internationalization ("I18n") module allows you to add multiple selectable languages to your project.


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Defining strings</h3>

            <p>
                Create an enum that defines all translatable strings that are in the game.
            </p>

            <pre class="line-numbers"><code class="language-c">enum {
                STR_HELLO,
                STR_VBJAENGINE_ROCKS
                };</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Languages files</h3>

            <p>
                For each language, define an array of strings. Make sure to keep the string order as defined in the enum
                above. You'll want to create one file per language definition.
                Ensure these files are encoded in ANSI for special characters ("umlauts") to work.
            </p>

            <p>
                The following gives an example for an English language definition file.
            </p>

            <pre class="line-numbers"><code class="language-c">static char* Lang_EN[] =
                {

                // STR_HELLO
                "Hello",

                // STR_VBJAENGINE_ROCKS
                "The VBJaEngine rocks!",

                };</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Registering languages</h3>

            <p>
                During the initialization phase of your game, inform the engine about available languages by registering
                each one using the <code>I18n_registerLanguage</code> method.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_registerLanguage(I18n_getInstance(), Lang_EN);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Setting active language</h3>

            <p>
                You can set the active language using the <code>I18n_setActiveLanguage</code> method. Each registered language
                is identified by an integer in the order they were registered, starting with 0. By default, the first
                registered language is used.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setActiveLanguage(I18n_getInstance(), 0);</code></pre>

            <p>
                For easier identification of your registered languages, you'll want to creating an enum with string
                identificators in the same order you register the languages with the engine. For example:
            </p>

            <pre class="line-numbers"><code class="language-c">enum {
                LANGUAGE_EN,
                LANGUAGE_DE
                };</code></pre>

            <p>
                If you made languages accessible through these, a call to change the language to German would look like
                the following.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setActiveLanguage(I18n_getInstance(), LANGUAGE_DE);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Getting a translated string</h3>

            <p>
                The <code>I18n_getText</code> method retrieves a string by a given identifier in the currently active
                language.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_getText(I18n_getInstance(), STR_HELLO)</code></pre>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Other useful classes</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VirtualList</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>OptionsSelector</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Errors</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Configuration</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>config.h</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Assets</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Managing and using graphical assets in VBDE</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Defaults</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Splash screens</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Low Battery Indicator</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Automatic Pause</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Debugging</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Debug Tools</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Debug System</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Stage Editor</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Animation Editor</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Macros</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>ASSERT & others</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Pre-processing</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Final clean-up to save some space and performance</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Building the master ROM</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>FAQ</h2>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Class reference</h2>



            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

        </div>

        <div class="col-md-3">
            <div class="sidebar hidden-print hidden-xs hidden-sm" role="complementary">
                <ul class="nav" id="jae-sidebar-toc">
                </ul>
            </div>
        </div>

    </div>
</div>

<footer role="contentinfo">
    <div class="container">
        <p>
            This document was last modified on <span id="footerLastModified"> </span>
            <script type="text/javascript">
                document.getElementById("footerLastModified").innerHTML = document.lastModified;
            </script>
        </p>
        <p>
            The VBJaEngine was written by Jorge Eremiev &lt;<a href="mailto:jorgech3@gmail.com">jorgech3@gmail.com</a>&gt;
        </p>
        <p>
            Copyright &copy; 2007, 2014
        </p>
        <ul class="footer-links muted">
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine" target="_blank">Bitbucket</a></li>
            <li>&middot;</li>
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine-skeleton" target="_blank">Skeleton</a></li>
            <li>&middot;</li>
            <li><a href="http://www.planetvb.com" target="_blank">Planet Virtual Boy</a></li>
        </ul>
    </div>
</footer>

<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/bootstrap.min.js"></script>
<script src="assets/prism/prism.js"></script>
<script src="assets/custom/script.js"></script>
<script src="assets/custom/create-toc.js"></script>
<script src="assets/custom/smooth-scroll.js"></script>
<script src="assets/ie/ie10-viewport-bug-workaround.js"></script>

</body>
</html>
