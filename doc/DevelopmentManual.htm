<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>VBJaEngine Development Manual</title>
    <link href="assets/bootstrap/bootstrap.min.css" rel="stylesheet">
    <link href="assets/bootstrap/bootstrap-theme.min.css" rel="stylesheet">
    <link href="assets/custom/style.css" rel="stylesheet">
    <link href="assets/prism/prism.css" rel="stylesheet" />
    <link rel="icon" href="assets/favicon.ico">

    <!--[if lt IE 9]>
    <script src="assets/ie/html5shiv.min.js"></script>
    <script src="assets/ie/respond.min.js"></script>
    <![endif]-->

</head>
<body>

<div class="abstract">
    <div class="container">
        <h1>// VBJaEngine Development Manual</h1>
        The VBJaEngine has been developed to fill the gap between the developer's game logic and the
        hardware management required to produce visual and audio results on the Nintendo Virtual Boy. The
        engine is a sprite based engine, which takes care of all the work necessary to display user defined
        sprite images on screen, allocating graphical and CPU's memory to hold the definitions of such
        images.
    </div>
</div>

<div class="container">

    <div class="row">
        <div class="col-md-9 documentation" role="main">

            <br><div class="alert alert-warning">
                This document is a work in progress and thus contains incomplete or partially outdated information.<br>
                If you have any problems which this document is unable to help you resolve, please refer to the
                <a href="http://www.planetvb.com/modules/newbb/viewforum.php?forum=14&since=0">VBJaEngine support forum</a>.
            </div>

            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Overview</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Features</h3>

            <p>
                The engine provides the following features for the programmer to take advantage of:
            </p>

            <ul>
                <li>Automatic Char memory allocation</li>
                <li>Automatic BGMap memory allocation</li>
                <li>Automatic OBJ memory allocation</li>
                <li>Automatic world layer assignment based on the object's Z position</li>
                <li>Automatic frame rate control</li>
                <li>Memory Pool to allocate memory dynamically</li>
                <li>Automatic memory allocation for Param tables (used in Affine and H-Bias modes)</li>
                <li>Easy to use printing functions to facilitate debug</li>
                <li>Sound reproduction of one BGM and up to two FX sounds simultaneously</li>
                <li>A generic container</li>
                <li>Messaging system</li>
                <li>Generic State Machine</li>
                <li>Automatic collision detection and notification</li>
                <li>Particle system</li>
                <li>Object Oriented support through the use of Metaprogramming (C MACROS):
                    <ul>
                        <li>Inheritance</li>
                        <li>Polymorphism</li>
                        <li>Encapsulation</li>
                    </ul>
                </li>
                <li>Useful classes to speed up the content creation process:
                    <ul>
                        <li>Image</li>
                        <li>Background</li>
                        <li>Character</li>
                        <li>Scroll</li>
                    </ul>
                </li>
                <li>Automatic loading/unloading of objects in/outside the screen</li>
                <li>3D stages</li>
                <li>Simple physics simulation:
                    <ul>
                        <li>Accelerated/uniform movement.</li>
                        <li>Gravity</li>
                        <li>Friction</li>
                        <li>Scaling/rotation effects.</li>
                    </ul>
                </li>
                <li>Clocking system</li>
                <li>Automatic projection/parallax/scale calculation and rendering</li>
                <li>Customizable perspective/deep effects on real time</li>
                <li>Frame based animation system with callback support</li>
                <li>Generic main game algorithm (game loop)</li>
            </ul>

            <h4>TODO</h4>

            <ul>
                <li>Polygons</li>
                <li>Tile based collision detection</li>
                <li>BGMAP defragmentation</li>
                <li>More collision shapes: spheres, complex polyhedrons, etc.</li>

            </ul>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Object Oriented Programming</h2>

            <p>
                Since the nature of games is better and more easily represented by the OOP paradigm than a
                structured one, because the former allows for better code re-usage and flexibility, and since the
                available compiler for the VB only supports C,a set of C MACROS have been created for this engine
                to simulate some of the most visible features provided by C++:
            </p>
            <ul>
                <li>Inheritance</li>
                <li>Polymorphism</li>
                <li>Encapsulation</li>
            </ul>
            <p>
                In order to use these features, you must be comfortable using some MACRO calls which will be
                explained next.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Creating a Class</h3>

            <p>
                Every class in the engine and the game must inherit from a base class called Object or from another
                class which inherits from it.
            </p>

            <p>
                Let's create a Hero class which inherits from the Character class provided with the engine. In the
                header file Hero.h the following macros must be placed. This will allow the Hero class to inherit the
                virtual methods from the Character class.
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_METHODS								        \
                    Character_METHODS;</code></pre>

            <p>
                Next, it is necessary to inherit and/or redefine those method's definitions.
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_SET_VTABLE(ClassName)						\
                    Character_SET_VTABLE(ClassName);						\
                    __VIRTUAL_SET(ClassName, Hero, die);</code></pre>

            <p>
                This tells the engine that Character has a virtual method called <code>die</code>
                (<code>Character_die</code> actually) and we want to redefine that method with our own version of
                <code>die</code>, thus allowing <i>Polymorphism</i>.
            </p>

            <p>
                Then you must declare the class with the following line:
            </p>

            <pre class="line-numbers"><code class="language-c">__CLASS(Hero);</code></pre>

            <p>
                This will define a pointer Hero to a struct, this way the Hero class's implementation is hidden from
                client code, making it impossible to access private members, which provides <i>Encapsulation</i>.
            </p>

            <p>
                Then you must declare Hero class's specific attributes, to do so, declare the following MACRO:
            </p>

                <pre class="line-numbers"><code class="language-c">#define Hero_ATTRIBUTES						        	\
                    \
/* it is derived from */					    		\
Character_ATTRIBUTES							    	\
														\
/* hero has energy	*/							        \
u8 energy;</code></pre>

            <p>
                Notice that all of these macros have a backslash ("\") at the end of each line, you must be careful and
                always be sure that there are no blank or tab spaces after them. The reason to declare the class's
                attributes this way is because this allows to inherit methods/attributes, and at the same time allows to
                make the attributes private. Notice that in order for Hero to inherit Character's attributes to include
                <code>Character_ATTRIBUTES</code> in <code>Hero_ATTRIBUTES</code>.
            </p>

            <p>
                The last thing to be done in the header file is to declare the following methods:
            </p>

            <p>
                <strong>Allocator:</strong> all classes must follow the following format (the arguments are optional).
            </p>
            <pre class="line-numbers"><code class="language-c">Hero Hero_new(CharacterDefinition* animatedEntityDefinition, int ID);</code></pre>

            <p>
                <strong>Constructor:</strong> the first argument is mandatory.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_constructor(Hero this, CharacterDefinition* definition, int ID);</code></pre>

            <p>
                <strong>Destructor:</strong> the argument is mandatory and must only be one in all cases.
            </p>
            <pre class="line-numbers"><code class="language-c">void Hero_destructor(Hero this);</code></pre>

            <p>
                Now it is time to define the class. In the source file Hero.c do as follows.
                Include the header file which holds the class's declaration:
            </p>

            <pre class="line-numbers"><code class="language-c">#include "Hero.h"</code></pre>

            <p>
                Define the class:
            </p>

                <pre class="line-numbers"><code class="language-c">// A Hero! Which inherits from Character
                    __CLASS_DEFINITION(Hero, Character);</code></pre>

            <p>
                Define the allocator:
            </p>

                <pre class="line-numbers"><code class="language-c">// always call these to macros next to each other
                    __CLASS_NEW_DEFINITION(Hero, ActorDefinition* actorDefinition, int ID)
                    __CLASS_NEW_END(Hero, this, actorDefinition, ID);</code></pre>

            <p>
                Define the constructor: must always call the parent class's constructor to properly initialize the object.
            </p>

                <pre class="line-numbers"><code class="language-c">// class's constructor
                    void Hero_constructor(Hero this, ActorDefinition* actorDefinition, int ID){

                    __CONSTRUCT_BASE(this, actorDefinition, ID);

                    this->energy = 1;

                    ...

                    } </code></pre>

            <p>
                Define the destructor: must always destroy the parent class at the end of the method.
            </p>

                <pre class="line-numbers"><code class="language-c">// class's destructor
                    void Hero_destructor(Hero this){

                    // free space allocated here

                    // delete the super object
                    __DEALLOCATE;
                    } </code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Virtual Calls</h3>

            <p>
                The purpose of having OOP features is to allow generic programming through the use of virtual calls
                to class methods through a base class pointer. For example, the Stage has a list of Entities (from
                which Character, Background and Image inherit) and it must be able to call the proper update and
                render methods on those classes. To do so, there are two possible ways:
            </p>

            <ol>
                <li>
                    Using a switch statement to determine which type of object is being pointed to by the parent
                    class pointer, which can mean having to store extra info on each object to hold the type, and
                    can be quite cumbersome if we extend to have more kind of Entities.
                </li>
                <li>
                    The other way is to use virtual calls to virtual methods, as shown below:
                </li>
            </ol>

                <pre class="line-numbers"><code class="language-c">// update each entity's internal state
                    void Stage_update(Stage this)
                    {
                    VirtualNode node = VirtualList_begin(this->entities);

                    for(; node ; node = VirtualNode_getNext(node)) {
                    __VIRTUAL_CALL(void, Entity, update,(Entity)VirtualNode_getData(node));
                    }
                    } </code></pre>

            <p>
                As you can see, there is only one call to the method, which depends on the type of object that is currently being processed.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Abstract classes</h3>

            <p>
                To define an abstract class, simply omit the <code>__VIRTUAL_SET</code> definition.
            </p>

            <p>
                Trying to instantiate an abstract Entity will result in an exception in <code>__DEBUG</code> mode.
            </p>

            <!--------------------------------------------------------------------------------------------------------->

            <h3>Friend classes</h3>

            <p>
                [[TODO]]
            </p>
            
            <!--------------------------------------------------------------------------------------------------------->

            <h3>Singletons</h3>

            <p>
                [[TODO]]
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Graphics</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>2D</h3>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>AnimatedSprite</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>Animation allocation types</h5>

            <p>
                Since there can be Characters with many frames of animations like the game's hero on one hand, and
                Characters with simple animations like enemies on the other hand, there is a need to allocate each
                kind in different ways. There are three ways to allocate animations in memory:
            </p>
            <b>__ANIMATED:</b>
            <p>
                Each Character has its dedicated Char and BGMap memory. On each animation frame change, the char
                definition is rewritten with the next.
                Since this kind of texture is the most expensive one performance-wise, it is recommended to use it
                only for either Characters with lots of animations, or when the number of chars for all the frames of
                animation is too large to be be allocated as <code>__ANIMATED_SHARED</code>
                (that'd be more than 511 chars, 1 is always reserved by the engine for each CharSet).
            </p>
            <b>__ANIMATED_SHARED:</b>
            <p>
                Both the Char and BGMap definitions are shared between Characters of the same type. All animation
                frames are allocated in both memories, so in order to display each animation frame, the world layer
                window is moved to the proper frame in case of BGMap mode being used, or the param table is rewritten in
                the case of affine mode.
                This is useful for example for an enemy Character which has few chars and few animation frames and when
                there are lot of the same Character on screen.
            </p>
            <b>__ANIMATED_SHARED_COORDINATED:</b>
            <p>
                [[TODO]]
            </p>
            <b>__NO_ANIMATED:</b>
            <p>
                Used with static images like backgrounds, logos, etc.
            </p>
            <p>
                In order to play a specific animation, call the following method:
            </p>
            <pre><code class="language-c">Character_playAnimation((Character)this, "Blink");</code></pre>
            <p>
                Or directly:
            </p>
            <pre><code class="language-c">AnimatedSprite_play((AnimatedSprite)this->sprite, this->characterDefinition->animationDescription, animationName); </code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>Sprite</h4>

                <h5>Displacement vector</h5>

                <p>
                    Displacement vectors in SpriteDefinitions are used to manipulate the Sprite's coordinates relative to
                    those of it's entity's parent <i>after</i> the projection from 3D to 2D space has taken place.
                    It is to be used...
                </p>

                <ul>
                    <li>
                        when you need to do "internal sorting" for multi sprite entities,
                        since the order of Sprites in the Definition are not reliable
                    </li>
                    <li>
                        when you want a Sprite to be always offset by a fixed number of pixels with respect to it's
                        parent's 2D position (can be used for parallax offsets too)
                    </li>
                </ul>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>Sprite</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>MSprite</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>SpriteManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>ParamTable</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>ParamTableManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>Texture</h4>


            <!--------------------------------------------------------------------------------------------------------->

            <h5>TextureManager</h5>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>3D</h3>

            <p>[not yet implemented]</p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->


            <h2>In-game object types</h2>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Container</h3>

            <p>
                A generic container for parenting purposes. Eases translation, rotation, scaling etc. of several entites
                at once.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Entity</h3>

            <p>
                A <code>Container</code> with a list of Sprites. It is the base class for any visual object.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>InGameEntity</h3>

            <p>
                Interactive entities in the levels, in general, they have a collision cuboid which Actors' cuboids test
                against for collisions.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>AnimatedInGameEntity</h3>

            <p>
                An entity with animated sprites.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>Actor</h4>

            <p>
                AnimatedInGameEntity with a physical body. It coordinates the collisions and the way the body must react
                to them. This class is designed to handle movable entities.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>InanimatedInGameEntity</h3>

            <p>
                InGameEntity with physical properties (friction, elasticity, etc.). In general, it is not supposed to move.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Image</h3>

            <p>
                Just a handy entity for non-interactive images.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Backgrounds</h3>

            <p>
                There are two ways to create repeating backgrounds.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>ScrollBackground</h4>

            <p>
                Simple class to create infinitely loop images out of two Textures, either different ones
                or two times the same one. It supports looping over the X axis only.
                It is easier to use than the <code>MBackground</code>, but is quite imperformant and should therefore be
                avoided if possible.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>MBackground</h4>

            <p>
                An infinitely looping background that is composed of a variable number of up to 8 BGMaps.
            </p>

            <p>
                This makes use of MSprite, which can be quite complex to use. Texture allocation must be planned ahead
                with texture preloading to work with multiple segments.
            </p>



            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Stage</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Streaming</h3>
                - Constructing a Stage: Here we have to address the PositionedEntity struct in detail, specially the extra info attribute which must only be used in "final" classes.


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Physics</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>PhysicalWorld</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Body</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Mass</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Collisions</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Shape</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Cuboid</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Circle</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Object interaction</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Messaging</h3>

            <p>
                [[TODO]]
            </p>

            <div class="alert alert-warning">
                Delayed messages must always be sent between objects that you know will be alive at the moment of
                delivery. Therefore you need to make sure to cancel any delayed messages in the destructor of each class
                that uses them. This is done with the <b>MessageDispatcher_discardDelayedMessages</b> method.
            </div>

            <div class="alert alert-warning">
                You can not send messages to States, you have to send to their owner instead.
            </div>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Event System</h3>

            <p>
                [[TODO]]
            </p>

            <p>
                - There is an event propagation capability in the engine
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>State Machine</h2>

            <p>
                The Game itself has a StateMachine to hold the actual state of it and execute the proper logic. So
                after creating the game, and before entering the game's infinite loop, it must enter a valid state:
            </p>

            <pre class="line-numbers"><code class="language-c">// Main game algorithm
                // There should not be need
                // to modify this.

                int main(void){

                // create the game
                Game game = Game_getInstance();

                // clear sprite memory
                vbClearScreen();

                // turn on the display
                vbDisplayOn();

                // set engine's initial state
                Game_setState(game, (State)PVBCCScreen_getInstance());

                // main game loop
                Game_update (game);

                // end program
                return true;
                } </code></pre>

            <p>
                As you can see, the game will enter the state PVBCCScreen first, and then will enter the game's main loop Game_update();
                PVBCCScreen is a game state which must perform and initialization, execute its logic, and change the game's current state to another one based on user input.
            </p>
            <p>
                In its initialization stage, PVBCCScreen loads a GameWorld definition which describes the Stage, and the Entities within it:
            </p>

            <pre class="line-numbers"><code class="language-c">// state's enter
                static void PVBCCScreen_enter(PVBCCScreen this, void* owner){

                //clear char and bgmap memory
                vbClearScreen();

                // reset the engine state
                Game_reset(Game_getInstance(), true);

                // load world's entities
                Stage_setup(Game_getStage(Game_getInstance()), &PVBCC_WR);

                // call the render to setup world entries
                Game_render(Game_getInstance());

                // make a fade in
                Game_FXFadeIn(Game_getInstance(), FADEDELAY);
                }</code></pre>

            <p>
                The Stage_setup method instructs the stage to load the world defined by PVBCC_WR.
            </p>

            <pre class="line-numbers"><code class="language-c">StageDefinition PVBCC_WR =
                {
                // size
                {
                // x
                384,
                // y
                228,
                // z
                10
                },
                //initial screen position
                {
                // x
                0,
                // y
                0,
                //z
                0
                },
                //background music
                NULL,

                //entities
                {
                {&PVBCC_LEFT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
                {&PVBCC_RIGHT_BG,{SCREEN_CENTER_X, SCREEN_CENTER_Y, 0}},
                {NULL, {0,0,0}},
                },
                };</code></pre>

            <p>
                A Stage is defined by its size, the initial screen position, a pointer to a BGM, and a list of Entities. There must be always a {NULL, {0,0,0}} at the end of the definition to inform the Stage that the Entity list ends there.
            </p>
            <p>
                Let's take a look at one of the Entities being loaded.
            </p>

            <pre class="line-numbers"><code class="language-c">ImageDefinition PVBCC_LEFT_BG =
                {
                {
                // object's class
                __TYPE(Image),

                // Sprite
                {
                // the texture
                &PVBCC_LEFT_TX,

                // bgmap mode ( BGMAP, AFFINE, H-BIAS)
                WRLD_BGMAP,

                // display mode
                WRLD_LON,
                },
                },
                };</code></pre>

            <p>
                The following line tells the Stage which kind of Entity is currently being loaded so the proper constructor is called.
            </p>

            <pre class="line-numbers"><code class="language-c">__TYPE(Image)</code></pre>

            <p>
                Then comes the Sprite definition, PVBCC_LEFT_TX is the address of the Texture to use with the Sprite. The Sprite definition dictates the texture display mode (affine, bgmap, h-bias) and the displays on which the image will be shown.
            </p>

            <pre class="line-numbers"><code class="language-c">TextureDefinition PVBCC_LEFT_TX =
                {

                // CharSet
                {
                // chDefinition,
                PVBCC_CHARSET_LEFT,

                // numChars,
                238,

                // allocation type
                __NO_ANIMATED
                },

                // bgmap definition
                PVBCC_MAP_LEFT,

                // cols (max 64)
                48,

                // rows (max 64)
                28,

                //palette number,
                0
                }; </code></pre>

            <p>
                PVBCC_CHARSET_LEFT and PVBCC_MAP_LEFT are the names of the const arrays with the char and bgmap definitions produced by programs like VIDE.
            </p>
            <p>
                Notice that the total cols and rows which represent the image's size, are 8's divisors since each char is 8 pixels wide and 8 pixels height.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>In-game clock</h2>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Hardware</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Memory Pool</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>HardwareManager</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Keypad</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Timers</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VIP</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VPU</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>SaveRAM</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Link Cable</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Sound</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Printing</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>The Printing Layer</h3>

            <p>
                Out of the VB's 32 available Worlds, the VBJaEngine reserves the highest one for text output.
                It provides methods to output different variable types to this so-called <i>Printing Layer</i>.
            </p>

            <ul>
                <li><code>Printing_text</code></li>
                <li><code>Printing_int</code></li>
                <li><code>Printing_float</code></li>
                <li><code>Printing_hex</code></li>
            </ul>

            <p>
                Here's an example that outputs the string "Hello, World!" at position {10, 0} using a custom font
                registered under the name "CustomFont".
            </p>

            <pre class="line-numbers"><code class="language-c">Printing_text(
    Printing_getInstance(), // Printing instance
    "Hello, World!", // text
    10, // x position
    0, // y position
    "CustomFont", // font name
);</code></pre>

            <p>
                The whole printing layer can be cleared with the <code>Printing_clear</code> method.
            </p>

            <p>
                Some aspects of the Printing Layer can be modified in your projects's <code>config.h</code> file.

                The palette for printing can be set to one of the 4 avaiable one with the
                <code>__PRINTING_PALETTE</code> setting.

                An offset of the printing layer can be defined using the
                <code>__PRINTING_BGMAP_X_OFFSET</code>, <code>__PRINTING_BGMAP_Y_OFFSET</code> and
                <code>__PRINTING_BGMAP_Z_OFFSET</code> settings.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Font management</h3>

            <p>
                The VBJaEngine comes with a default font for writing to the Printing Layer, but you can replace it with
                any number of custom fonts. To tell the engine to ignore the default font and load your custom
                font(s) instead, you have to define the <code>__CUSTOM_FONTS</code> macro in your
                game's <code>config.h</code> file.
            </p>

            <pre><code class="language-c">#define __CUSTOM_FONTS</code></pre>

            <p>
                With that macro defined, the engine expects you to define a <i>NULL-terminated</i> array of pointers to
                <code>FontROMDef</code> definitions called <code>__FONTS</code>. The following example defines a
                single 8x8 pixel font as a direct replacement for the built-in default font.
            </p>

            <pre class="line-numbers"><code class="language-c">extern BYTE font8x8Tiles[];

FontROMDef FONT_8x8 =
{
    // font chars definition pointer
    font8x8Tiles,

    // number of characters in font
    256,

    // character number at which the font starts, allows you to skip the control characters for example
    0,

    // size of a single character (in chars) ({width, height})
    {1, 1},

    // font's name
    "Font8x8",
};

const FontROMDef* __FONTS[] =
{
    &FONT_8x8,
    NULL
};</code></pre>

            <p>
                Note that the first font in the <code>__FONTS</code> array is always the default one, and is used when
                <code>NULL</code> is passed to the various Printing methods instead of a font name.
            </p>

            <p>
                The engine's default font will not be loaded when custom fonts are enabled. If you still want to use it,
                simply add <code>&VBJAENGINE_FONT</code> to your <code>__FONTS</code> array.
                It will then be accessible under the name "VBJaEngineFont".
                Don't forget to also declare it as extern in your font definition file, like so:
                <code>extern FontROMDef VBJAENGINE_FONT;</code>.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Internationalization</h2>

            The Internationalization ("I18n") module allows you to add multiple selectable languages to your project.


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Defining strings</h3>

            <p>
                Create an enum that defines all translatable strings that are in the game.
            </p>

            <pre class="line-numbers"><code class="language-c">enum {
    STR_HELLO,
    STR_VBJAENGINE_ROCKS
};</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Languages files</h3>

            <p>
                For each language, create a LangROMDef, which consists of a language name string and an array of
                strings. Make sure to keep the string order as defined in the enum
                above. You'll want to create one file per language definition.
                Ensure these files are encoded in ANSI for special characters ("umlauts") to work.
            </p>

            <p>
                The following gives an example for an English language definition.
            </p>

            <pre class="line-numbers"><code class="language-c">LangROMDef LANGUAGE_EN =
{
    // Language Name
    "English",

    {
        // STR_HELLO
        "Hello",

        // STR_VBJAENGINE_ROCKS
        "The VBJaEngine rocks! :-)",
    },
};</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Registering languages</h3>

            <p>
                During the initialization phase of your game, inform the engine about available languages by registering
                each one using the <code>I18n_registerLanguage</code> method.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_registerLanguage(I18n_getInstance(), &LANGUAGE_EN);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Setting active language</h3>

            <p>
                You can set the active language using the <code>I18n_setActiveLanguage</code> method. Each registered
                language is identified by an integer in the order they were registered, starting with 0. By default,
                the first registered language is used.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setActiveLanguage(I18n_getInstance(), 0);</code></pre>

            <p>
                Alternatively, you can also use the
                <code>I18n_setActiveLanguageByName</code> method to set the active language by one of the language names
                defined in your LangROMDefs.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_setActiveLanguageByName(I18n_getInstance(), "English");</code></pre>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Getting a translated string</h3>

            <p>
                The <code>I18n_getText</code> method retrieves a string by a given identifier in the currently active
                language.
            </p>

            <pre class="line-numbers"><code class="language-c">I18n_getText(I18n_getInstance(), STR_HELLO);</code></pre>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Other useful classes</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>VirtualList</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>OptionsSelector</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Errors</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Configuration</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>config.h</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Assets</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Managing and using graphical assets in VBDE</h3>

            <p>
                VBDE allows for hassle free, on-the-fly image conversion using
                grit. To use it, create a folder called "assets" in the root
                folder of your project, with a contained "images" folder. This
                folder will hold all your images in any of the supported
                formats: png, bmp, gif, pcx or jpg/jpeg (I recommend png.)
            </p>

            <p>
                Images should use an indexed 4-color palette in the following
                order: Black, Dark Red, Medium Red, Light Red. An example palette
                for Photoshop can be found in {VBDE}/system/grit/.
            </p>

            <p>
                In order to be detected and converted by the image conversion
                script, you also need a *.grit file of the same name as the
                graphic, which contains the conversion settings. You can find
                a number of example grit files in {VBDE}/system/grit/ which you
                can just copy and paste (and rename) into your images folder.
            </p>

            <p>
                You can also make several files convert at once instead of
                having all images converted individually. Grit files which do not
                directly relate to an image file through their name, are applied
                to all images files in the current directory (not sub-directories.)
                This is useful for generating maps with shared tilesets.
            </p>

            <p>
                Example file structure:<br>
                my-project/<br>
                '- assets/<br>
                '- images/<br>
                |- backgrounds/<br>
                |  |- Backgrounds.grit<br>
                |  |- Background-1.png<br>
                |  '- Background-2.png<br>
                |- Font.grit<br>
                '- Font.png<br>
                |- Hero.grit<br>
                '- Hero.png<br>
            </p>

            <p>
                Finally, to start the image conversion, press the editor's
                grit button while having any project file opened. This will
                convert all images that do not yet have a corresponding c file
                or are newer than their c file.
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Defaults</h2>

            <p>
                The VBJaEngine includes defaults for common Virtual Boy software features.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Splash screens</h3>

            <p>
                Default versions of common screens are available in the VBJaEngine Barebone.
                Those can easily be directly used, modified, replaced and/or reordered and eliminate the need to
                create those by hand.
            </p>

            <ol>
                <li>Adjustment screen</li>
                <li>Precaution screen</li>
                <li>Automatic Pause selection screen</li>
                <li>Language selection screen</li>
                <li>VBJaEngine splash screen</li>
                <li>Automatic Pause screen</li>
            </ol>

            <!--------------------------------------------------------------------------------------------------------->

            <h3>Low Battery indicator</h3>

            <p>
                When the Virtual Boy's batteries are low, a flashing low battery indicator is shown on screen. To
                enable this feature, define the <code>__LOW_BATTERY_INDICATOR</code> macro in your game's
                <code>config.h</code> file.
            </p>

            <p>
                The indicator's default position {45, 1}. It can be changed through the
                <code>__LOW_BATTERY_INDICATOR_POS_X</code> and <code>__LOW_BATTERY_INDICATOR_POS_Y</code> macros.
                You can furthermore change the initial delay of the low battery indicator through the
                <code>__LOW_BATTERY_INDICATOR_INITIAL_DELAY</code> macro as well as the blinking delay through the
                <code>__LOW_BATTERY_INDICATOR_BLINK_DELAY</code> macro in your game's
                <code>config.h</code> file.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h3>Automatic Pause</h3>

            <p>
                An Automatic Pause screen is shown after approximately 30 minutes of gameplay.
            </p>

            <p>
                The amount of time after which the Automatic Pause screen is shown can be changed through the
                <code>__AUTO_PAUSE_DELAY</code> setting, to be made in your projects's <code>config.h</code> file.
            </p>

            <p>
                You can also set your own state to be used for the Automatic Pause screen using the
                <code>Game_setAutomaticPauseState</code> function. Here's an example:
            </p>

            <pre class="line-numbers"><code class="language-c">Game_setAutomaticPauseState(Game_getInstance(), (GameState)CustomAutoPauseScreenState_getInstance());</code></pre>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Debugging</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Debug Tools</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Debug System</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Stage Editor</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Animation Editor</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Macros</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h4>__GET_CLASS_NAME</h4>

            <p>
                Get the class of an object using this macro.
            </p>


            <!--------------------------------------------------------------------------------------------------------->

            <h4>ASSERTs</h4>

            <p>
                The engine provides two kinds of ASSERT macros, which check a given statement and throw an exception
                with a given error message if this statement returns false.
                These macros should be used thoughout the code to make debugging easier.
                Since the engine relies on heavy pointer usage, it can happen easily to get a bad pointer and get lost.
            </p>

            <h5>ASSERT</h5>

            <p>
                Only inserted when compiling under debug. It is used at the start of most of the
                engine's methods to check that the "this" pointer is not NULL.
                Since the MemoryPool writes a 0 in the first byte of a deleted pointer, this helps to
                assure that any memory slot within the MemoryPool's pools has a 0 when it has been deleted.
            </p>

            <p>
                Another good usecase for this would be to check an object's class name against the expected class as
                shown below.
            </p>

            <pre class="line-numbers"><code class="language-c">ASSERT(!strcmp(__GET_CLASS_NAME(someObject), SomeClass_getClassName()), "Wrong object class");</code></pre>

            <h5>NM_ASSERT</h5>

            <p>
                Inserted under any compilation type (NM stands for "non maskerable").
                This macro is meant to be placed in sensible parts of the code.
                Here's a few examples of usage in the VBJaEngine:
            </p>

            <ul>
                <li>
                    <b>MemoryPool allocation</b><br>
                    To let you know that the memory is full, otherwise extremely hard to track bugs occur
                </li>
                <li>
                    <b>SpriteManager, registering a new Sprite</b><br>
                    To let you know that there are no more WORLDs available
                </li>
                <li>
                    <b>ParamTableManager, registering a new Sprite</b><br>
                    To let you know that param memory is depleted
                </li>
            </ul>

            <h5>Debugging Exceptions</h5>

            <p>
                When an exception is thrown in-game in debug mode, you're presented with some output that's meant to
                help you find the exact location that is causing the crash.
                These are last process, LP and SP as well as the exception message.
            </p>

            <p>
                Looking for the message in both your game code as well as the engine would be the quickest thing to do
                but should give you only a rough idea of the problem's root in most cases.
            </p>

            <p>
                The LP (linker pointer) value shows you the exact location in memory where the crash occured and will lead you to the
                function that has caused it. Look for the line "@$(OBJDUMP) -S main.elf > machine.asm" in your project's
                makefile, uncomment it and recompile. The compiler will produce a file called "machine.asm" in the
                project's root folder. It contains a huge list of all functions, their ASM equivalent and
                memory locations. Search it for your LP value and it will lead you to the faulty function.
            </p>

            <p>
                The SP (stack pointer) value becomes useful in the (seldom) case of a stack overflow.
                Since the check is performed during a timer interrupt, it is possible that an overflow occurs between interrupts.
                By checking the SP value against the __lastDataVariable address in the sections.txt file, you can guess that there was an overflow.
                As described for the machine.asm file above, activate generation of the sections.txt file in the makefile.
            </p>



            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Post-processing</h2>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Final clean-up to save some space and performance</h3>



            <!--------------------------------------------------------------------------------------------------------->

            <h3>Building the master ROM</h3>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>FAQ</h2>

            <p>
                <b>
                    All of a sudden, I am getting a lot of different exceptions which I can't seem to find
                    a reason for in the code. What's going on?
                </b>
            </p>

            <p>
                When things begin to break unexpectedly and in random places, it is almost guaranteed that a stack
                overflow is the cause. In that case, you need to shrink down the memory pools.
            </p>

            <p>
                <b>
                    I am getting the following error after compiling, what does it mean?
                </b>
                <pre>/opt/gccvb/lib/gcc/v810/4.4.2/../../../../v810/bin/ld: main.elf section '.bss' will not fit in region 'ram'
/opt/gccvb/lib/gcc/v810/4.4.2/../../../../v810/bin/ld: region 'ram' overflowed by xx bytes</pre>
            </p>

            <p>
                In the context of the engine, it means that the memory pool is too big. You're trying to
                reserve more RAM than physically exists.
            </p>

            <p>
                <b>What does "VBJaEngine" stand for anyway?</b>
            </p>

            <p>
                "JaE" are the initials of the engine's lead developer, Jorge Andres Eremiev.
                You'll figure the rest out yourself from here. ;-)
            </p>


            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

            <h2>Class reference</h2>



            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->
            <!--------------------------------------------------------------------------------------------------------->

        </div>

        <div class="col-md-3">
            <div class="sidebar hidden-print hidden-xs hidden-sm" role="complementary">
                <ul class="nav" id="jae-sidebar-toc">
                </ul>
            </div>
        </div>

    </div>
</div>

<footer role="contentinfo">
    <div class="container">
        <p>
            This document was last modified on <span id="footerLastModified"> </span>
            <script type="text/javascript">
                document.getElementById("footerLastModified").innerHTML = document.lastModified;
            </script>
        </p>
        <p>
            The VBJaEngine was written by Jorge Eremiev &lt;<a href="mailto:jorgech3@gmail.com">jorgech3@gmail.com</a>&gt;
        </p>
        <p>
            Copyright &copy; 2007, 2014
        </p>
        <ul class="footer-links muted">
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine" target="_blank">Bitbucket</a></li>
            <li>&middot;</li>
            <li><a href="https://bitbucket.org/jorgeche/vbjaengine-skeleton" target="_blank">Skeleton</a></li>
            <li>&middot;</li>
            <li><a href="http://www.planetvb.com" target="_blank">Planet Virtual Boy</a></li>
        </ul>
    </div>
</footer>

<script src="assets/jquery/jquery.min.js"></script>
<script src="assets/bootstrap/bootstrap.min.js"></script>
<script src="assets/prism/prism.js"></script>
<script src="assets/custom/script.js"></script>
<script src="assets/custom/create-toc.js"></script>
<script src="assets/custom/smooth-scroll.js"></script>
<script src="assets/ie/ie10-viewport-bug-workaround.js"></script>

</body>
</html>
