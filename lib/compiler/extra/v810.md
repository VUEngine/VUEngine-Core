;; GCC machine description for NEC V810
;; Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.

;;   Contributed by Jeff Law (law@cygnus.com).

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; The original PO technology requires these to be ordered by speed,
;; so that assigner will pick the fastest.

;; See file "rtl.def" for documentation on define_insn, match_*, et. al.

;; The V851 manual states that the instruction address space is 16M;
;; the various branch/call instructions only have a 22bit offset (4M range).
;;
;; One day we'll probably need to handle calls to targets more than 4M
;; away.

;; The size of instructions in bytes.

(define_attr "length" ""
  (const_int 200))

(define_attr "long_calls" "yes,no"
  (const (if_then_else (symbol_ref "TARGET_LONG_CALLS")
		       (const_string "yes")
		       (const_string "no"))))

(define_attr "prolog_function" "yes,no"
  (const (if_then_else (symbol_ref "TARGET_PROLOG_FUNCTION")
		       (const_string "yes")
		       (const_string "no"))))

;; Types of instructions (for scheduling purposes).

(define_attr "type" "load,store,mul,div,udiv,other"


  (const_string "other"))

;; Condition code settings.
;; none - insn does not affect cc
;; none_0hit - insn does not affect cc but it does modify operand 0
;;	This attribute is used to keep track of when operand 0 changes.
;; 	See the description of NOTICE_UPDATE_CC for more info.
;; set_znv - sets z,n,v to usable values; c is unknown.
;; set_zn  - sets z,n to usable values; v,c is unknown.
;; compare - compare instruction
;; clobber - value of cc is unknown
(define_attr "cc" "none,none_0hit,set_zn,set_znv,compare,clobber"
  (const_string "clobber"))


;; Function units for the V810.  As best as I can tell, there's
;; a traditional memory load/use stall as well as a stall if
;; the result of a multiply is used too early.
;;

;;(define_function_unit "mem" 1 0 (eq_attr "type" "load") 2 0)
;;(define_function_unit "mem" 1 0 (eq_attr "type" "store") 1 2 [(eq_attr "type" "load")])
;; (define_function_unit "ex" 1 0 (eq_attr "type" "other") 1 0)
;;(define_function_unit "ex" 1 0 (eq_attr "type" "mul") 2 2)
;;(define_function_unit "ex" 1 0 (eq_attr "type" "div") 37 37)
;;(define_function_unit "ex" 1 0 (eq_attr "type" "udiv") 35 35)


(define_insn_reservation "v810_other" 1
			 (eq_attr "type" "other")
			 "nothing")
(define_insn_reservation "v810_mult" 2
			 (eq_attr "type" "mult")
			 "nothing")
(define_insn_reservation "v810_memory" 2
			 (eq_attr "type" "load")
			 "nothing")

(include "predicates.md")


;; ----------------------------------------------------------------------
;; MOVE INSTRUCTIONS
;; ----------------------------------------------------------------------

;; movqi

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, QImode)
      && !reg_or_0_operand (operand1, QImode))
    operands[1] = copy_to_mode_reg (QImode, operand1);
}")

(define_insn "*movqi_internal"
  [(set (match_operand:QI 0 "general_operand" "=r,r,r,Q,r,m,m")
	(match_operand:QI 1 "general_operand" "Jr,n,Q,Ir,m,r,I"))]
  "register_operand (operands[0], QImode)
   || reg_or_0_operand (operands[1], QImode)"
  "* return output_move_single (operands);"
  [(set_attr "length" "2,4,2,2,4,4,4")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,load,store,load,store,store")])

;; movhi

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, HImode)
      && !reg_or_0_operand (operand1, HImode))
    operands[1] = copy_to_mode_reg (HImode, operand1);
}")

(define_insn "*movhi_internal"
  [(set (match_operand:HI 0 "general_operand" "=r,r,r,Q,r,m,m")
	(match_operand:HI 1 "general_operand" "Jr,n,Q,Ir,m,r,I"))]
  "register_operand (operands[0], HImode)
   || reg_or_0_operand (operands[1], HImode)"
  "* return output_move_single (operands);"
  [(set_attr "length" "2,4,2,2,4,4,4")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,load,store,load,store,store")])

;; movsi and helpers

(define_insn "*movsi_high"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(high:SI (match_operand 1 "" "")))]
  ""
  "movhi hi(%1),%.,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")
   (set_attr "type" "other")])

(define_insn "*movsi_lo"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
		   (match_operand:SI 2 "immediate_operand" "i")))]
  ""
  "movea lo(%2),%1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")
   (set_attr "type" "other")])

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, SImode)
      && !reg_or_0_operand (operand1, SImode))
    operands[1] = copy_to_mode_reg (SImode, operand1);

  /* Some constants, as well as symbolic operands
     must be done with HIGH & LO_SUM patterns.  */
  if (CONSTANT_P (operands[1])
      && GET_CODE (operands[1]) != HIGH
      && !special_symbolref_operand (operands[1], VOIDmode)
      && !(GET_CODE (operands[1]) == CONST_INT
	   && (CONST_OK_FOR_J (INTVAL (operands[1]))
	       || CONST_OK_FOR_K (INTVAL (operands[1]))
	       || CONST_OK_FOR_L (INTVAL (operands[1])))))
    {
      rtx high;
      rtx temp;

      if (reload_in_progress || reload_completed)
        temp = operands[0];
      else
	temp = gen_reg_rtx (SImode);

      emit_insn (gen_rtx (SET, SImode, temp,
                          gen_rtx (HIGH, SImode, operand1)));
      emit_insn (gen_rtx (SET, SImode, operand0,
                          gen_rtx (LO_SUM, SImode, temp, operand1)));
      DONE;
    }
}")

(define_insn "*movsi_internal"
  [(set (match_operand:SI 0 "general_operand" "=r,r,r,r,Q,r,r,m,m")
	(match_operand:SI 1 "movsi_source_operand" "Jr,K,L,Q,Ir,m,R,r,I"))]
  "register_operand (operands[0], SImode)
   || reg_or_0_operand (operands[1], SImode)"
  "* return output_move_single (operands);"
  [(set_attr "length" "2,4,4,2,2,4,4,4,4")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,other,load,store,load,other,store,store")])



(define_expand "movdi"
  [(set (match_operand:DI 0 "general_operand" "")
	(match_operand:DI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, DImode)
      && !reg_or_0_operand (operand1, DImode))
    operands[1] = copy_to_mode_reg (DImode, operand1);
}")

(define_insn "*movdi_internal"
  [(set (match_operand:DI 0 "general_operand" "=r,r,r,r,r,m,m,r")
	(match_operand:DI 1 "general_operand" "Jr,K,L,i,m,r,IG,iF"))]
  "register_operand (operands[0], DImode)
   || reg_or_0_operand (operands[1], DImode)"
  "* return output_move_double (operands);"
  [(set_attr "length" "4,8,8,16,8,8,8,16")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,other,other,load,store,store,other")])

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, SFmode)
      && !reg_or_0_operand (operand1, SFmode))
    operands[1] = copy_to_mode_reg (SFmode, operand1);
}")

(define_insn "*movsf_internal"
  [(set (match_operand:SF 0 "general_operand" "=r,r,r,r,r,Q,r,m,m,r")
	(match_operand:SF 1 "general_operand" "Jr,K,L,n,Q,Ir,m,r,IG,iF"))]
  "register_operand (operands[0], SFmode)
   || reg_or_0_operand (operands[1], SFmode)"
  "* return output_move_single (operands);"
  [(set_attr "length" "2,4,4,8,2,2,4,4,4,8")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,other,other,load,store,load,store,store,other")])

(define_expand "movdf"
  [(set (match_operand:DF 0 "general_operand" "")
	(match_operand:DF 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, DFmode)
      && !reg_or_0_operand (operand1, DFmode))
    operands[1] = copy_to_mode_reg (DFmode, operand1);
}")

(define_insn "*movdf_internal"
  [(set (match_operand:DF 0 "general_operand" "=r,r,r,r,r,m,m,r")
	(match_operand:DF 1 "general_operand" "Jr,K,L,i,m,r,IG,iF"))]
  "register_operand (operands[0], DFmode)
   || reg_or_0_operand (operands[1], DFmode)"
  "* return output_move_double (operands);"
  [(set_attr "length" "4,8,8,16,8,8,8,16")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit")
   (set_attr "type" "other,other,other,other,load,store,store,other")])


(define_insn "floatsisf2"
  [(set (match_operand:SF 0 "register_operand" "=r")
	(float:SF (match_operand:SI 1 "register_operand" "r")))]
  ""
  "cvt.ws %1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "fix_truncsfsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
  ""
  "cvt.sw %1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])






;; ----------------------------------------------------------------------
;; TEST INSTRUCTIONS
;; ----------------------------------------------------------------------

;; This replaces ld.b;sar;andi with tst1;setf nz.

;; ??? The zero_extract sets the Z bit to the opposite of what one would
;; expect.  This perhaps should be wrapped in a (eq: X (const_int 0)).

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extract:SI (match_operand:QI 1 "memory_operand" "")
			 (const_int 1)
			 (match_operand 2 "const_int_operand" "")))]
  ""
  [(set (cc0) (zero_extract:SI (match_dup 1)
			       (const_int 1)
			       (match_dup 2)))
   (set (match_dup 0) (ne:SI (cc0) (const_int 0)))])

(define_insn "tstsi"
  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
  ""
  "cmp %.,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_insn "cmpsi"
  [(set (cc0)
	(compare (match_operand:SI 0 "register_operand" "r,r")
		 (match_operand:SI 1 "reg_or_int5_operand" "r,J")))]
  ""
  "@
  cmp %1,%0
  cmp %1,%0"
  [(set_attr "length" "2,2")
   (set_attr "cc" "compare")])

(define_insn "cmpsf"
  [(set (cc0)
	(compare (match_operand:SF 0 "register_operand" "r")
		 (match_operand:SF 1 "reg_or_int5_operand" "r")))]
  ""
  "cmpf.s %1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "compare")])


;; ----------------------------------------------------------------------
;; NEG INSTRUCTIONS
;; ----------------------------------------------------------------------
(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(neg:SI (match_operand:SI 1 "register_operand" "r")))]
  ""
  "not %1,%0\;add 1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])



;; ----------------------------------------------------------------------
;; ADD INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0,r,r")
		 (match_operand:SI 2 "nonmemory_operand" "rJ,K,U")))]
  ""
  "@
   add %2,%0
   addi %2,%1,%0
   addi %O2(%P2),%1,%0"
  [(set_attr "length" "2,4,4")
   (set_attr "cc" "set_zn,set_zn,set_zn")])

(define_insn "addsf3"
  [(set (match_operand:SF 0 "register_operand" "=r")
	(plus:SF (match_operand:SF 1 "register_operand" "%0")
		 (match_operand:SF 2 "register_operand" "r")))]
  ""
  "addf.s %2,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

;; ----------------------------------------------------------------------
;; SUBTRACT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(minus:SI (match_operand:SI 1 "register_operand" "0")
		  (match_operand:SI 2 "register_operand" "r")))]
  ""
  "sub %2,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn "subsf3"
  [(set (match_operand:SF 0 "register_operand" "=r")
	(minus:SF (match_operand:SF 1 "register_operand" "0")
		 (match_operand:SF 2 "register_operand" "r")))]
  ""
  "subf.s %2,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])


;; ----------------------------------------------------------------------
;; MULTIPLY INSTRUCTIONS
;; ----------------------------------------------------------------------

;;(define_insn "mulsi3_v830"
;;  [(set (match_operand:SI 0 "register_operand" "=r,r")
;;	(mult:SI (match_operand:SI 1 "register_operand" "%0,r")
;;		 (match_operand:SI 2 "nonmemory_operand" "r,K")))
;;   (clobber (reg:SI 30))]
;;  "TARGET_V830"
;;  "@
;;  mul %2,%0
;;  muli %2,%1,%0"
;;  [(set_attr "length" "2,4")
;;   (set_attr "cc" "set_zn,set_zn")])

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI (match_operand:SI 1 "register_operand" "%0")
		 (match_operand:SI 2 "nonmemory_operand" "r")))
   (clobber (reg:SI 30))]
  ""
  "mul %2,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")
   (set_attr "type" "mul")])

(define_insn "mulsf3"
  [(set (match_operand:SF 0 "register_operand" "=r")
	(mult:SF (match_operand:SF 1 "register_operand" "%0")
		 (match_operand:SF 2 "register_operand" "r")))]
  ""
  "mulf.s %2,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])


;; ----------------------------------------------------------------------
;; DIVISION INSTRUCTIONS
;; ----------------------------------------------------------------------
(define_insn "divsf3"
  [(set (match_operand:SF 0 "register_operand" "=r")
	(div:SF (match_operand:SF 1 "register_operand" "0")
		 (match_operand:SF 2 "register_operand" "r")))]
  ""
  "divf.s %2,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "divmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(div:SI (match_operand:SI 1 "register_operand" "0")
		(match_operand:SI 2 "register_operand" "r")))
   (set (match_operand:SI 3 "register_operand" "=r")
	(mod:SI (match_dup 1)
		(match_dup 2)))
   (clobber (reg:SI 30))]
  ""
  "div %2,%0\;mov r30,%3"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "divsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(div:SI (match_operand:SI 1 "register_operand" "0")
		(match_operand:SI 2 "register_operand" "r")))
   (clobber (reg:SI 30))]
  ""
  "div %2,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")
   (set_attr "type" "div")])

(define_insn "udivmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(udiv:SI (match_operand:SI 1 "register_operand" "0")
		(match_operand:SI 2 "register_operand" "r")))
   (set (match_operand:SI 3 "register_operand" "=r")
	(umod:SI (match_dup 1)
		(match_dup 2)))
   (clobber (reg:SI 30))]
  ""
  "divu %2,%0\;mov r30,%3"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "udivsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(udiv:SI (match_operand:SI 1 "register_operand" "0")
		(match_operand:SI 2 "register_operand" "r")))
   (clobber (reg:SI 30))]
  ""
  "divu %2,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")
   (set_attr "type" "udiv")])





;; ----------------------------------------------------------------------
;; AND INSTRUCTIONS
;; ----------------------------------------------------------------------




(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
	(and:SI (match_operand:SI 1 "register_operand" "%0,0,r")
		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))]
  ""
  "@
  and %2,%0
  and %.,%0
  andi %2,%1,%0"
  [(set_attr "length" "2,2,4")
   (set_attr "cc" "set_znv")])

;; ----------------------------------------------------------------------
;; OR INSTRUCTIONS
;; ----------------------------------------------------------------------




(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
	(ior:SI (match_operand:SI 1 "register_operand" "%0,0,r")
		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))]
  ""
  "@
  or %2,%0
  or %.,%0
  ori %2,%1,%0"
  [(set_attr "length" "2,2,4")
   (set_attr "cc" "set_znv")])

;; ----------------------------------------------------------------------
;; XOR INSTRUCTIONS
;; ----------------------------------------------------------------------




(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
	(xor:SI (match_operand:SI 1 "register_operand" "%0,0,r")
		(match_operand:SI 2 "nonmemory_operand" "r,I,M")))]
  ""
  "@
  xor %2,%0
  xor %.,%0
  xori %2,%1,%0"
  [(set_attr "length" "2,2,4")
   (set_attr "cc" "set_znv")])


;; ----------------------------------------------------------------------
;; NOT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(not:SI (match_operand:SI 1 "register_operand" "r")))]
  ""
  "not %1,%0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])


;; ----------------------------------------------------------------------
;; MIN INSTRUCTION
;; ----------------------------------------------------------------------
(define_insn "sminsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(smin:SI (match_operand:SI 1 "register_operand" "r")
		(match_operand:SI 2 "nonmemory_operand" "r")))]
  "TARGET_V830"
  "min3 %2,%1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])


;; ----------------------------------------------------------------------
;; MAX INSTRUCTION
;; ----------------------------------------------------------------------
(define_insn "smaxsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(smax:SI (match_operand:SI 1 "register_operand" "r")
		(match_operand:SI 2 "nonmemory_operand" "r")))]
  "TARGET_V830"
  "max3 %2,%1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])




;; -----------------------------------------------------------------
;; BIT FIELDS
;; -----------------------------------------------------------------

;; ??? Is it worth defining insv and extv for the V810 series?!?

;; An insv pattern would be useful, but does not get used because
;; store_bit_field never calls insv when storing a constant value into a
;; single-bit bitfield.

;; extv/extzv patterns would be useful, but do not get used because
;; optimize_bitfield_compare in fold-const usually converts single
;; bit extracts into an AND with a mask.

;; -----------------------------------------------------------------
;; Scc INSTRUCTIONS
;; -----------------------------------------------------------------

(define_insn "sle"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (le:SI (cc0) (const_int 0)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)
    return 0;

  return \"setf le,%0\";
}"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sleu"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (leu:SI (cc0) (const_int 0)))]
  ""
  "setf nh,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sge"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (ge:SI (cc0) (const_int 0)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)
    return 0;

  return \"setf ge,%0\";
}"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sgeu"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (geu:SI (cc0) (const_int 0)))]
  ""
  "setf nl,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "slt"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (lt:SI (cc0) (const_int 0)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)
    return 0;

  return \"setf lt,%0\";
}"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sltu"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (ltu:SI (cc0) (const_int 0)))]
  ""
  "setf l,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sgt"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (gt:SI (cc0) (const_int 0)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0)
    return 0;

  return \"setf gt,%0\";
}"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sgtu"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (gtu:SI (cc0) (const_int 0)))]
  ""
  "setf h,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "seq"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (eq:SI (cc0) (const_int 0)))]
  ""
  "setf z,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

(define_insn "sne"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (ne:SI (cc0) (const_int 0)))]
  ""
  "setf nz,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])



;; ----------------------------------------------------------------------
;; JUMP INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Conditional jump instructions

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_insn "*branch_normal"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
	  || GET_CODE (operands[1]) == GE
	  || GET_CODE (operands[1]) == LE
	  || GET_CODE (operands[1]) == LT))
    return 0;

  if (get_attr_length (insn) == 2)
    return \"b%b1 %l0\";
  else
    return \"b%B1 .+6\;jr %l0\";
}"
 [(set (attr "length")
    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
		      (const_int 256))
		  (const_int 2)
		  (const_int 6)))
  (set_attr "cc" "none")])

(define_insn "*branch_invert"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
	  || GET_CODE (operands[1]) == GE
	  || GET_CODE (operands[1]) == LE
	  || GET_CODE (operands[1]) == LT))
    return 0;
  if (get_attr_length (insn) == 2)
    return \"b%B1 %l0\";
  else
    return \"b%b1 .+6\;jr %l0\";
}"
 [(set (attr "length")
    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
		      (const_int 256))
		  (const_int 2)
		  (const_int 6)))
  (set_attr "cc" "none")])

;; Unconditional and other jump instructions.

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"br %0\";
  else
    return \"jr %0\";
}"
 [(set (attr "length")
    (if_then_else (lt (abs (minus (match_dup 0) (pc)))
		      (const_int 256))
		  (const_int 2)
		  (const_int 4)))
  (set_attr "cc" "none")])

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
  ""
  "jmp %0"
  [(set_attr "length" "2")
   (set_attr "cc" "none")])

(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "jmp  %0"
  [(set_attr "length" "2")
   (set_attr "cc" "none")])

(define_expand "casesi"
  [(match_operand:SI 0 "register_operand" "")
   (match_operand:SI 1 "register_operand" "")
   (match_operand:SI 2 "register_operand" "")
   (match_operand 3 "" "") (match_operand 4 "" "")]
  ""
  "
{
  rtx reg = gen_reg_rtx (SImode);
  rtx tableaddress = gen_reg_rtx (SImode);
  rtx mem;

  /* Subtract the lower bound from the index.  */
  emit_insn (gen_subsi3 (reg, operands[0], operands[1]));
  /* Compare the result against the number of table entries.  */
  emit_insn (gen_cmpsi (reg, operands[2]));
  /* Branch to the default label if out of range of the table.  */
  emit_jump_insn (gen_bgtu (operands[4]));

  /* Shift index for the table array access.  */
  emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));
  /* Load the table address into a pseudo.  */
  emit_insn (gen_movsi (tableaddress,
			gen_rtx (LABEL_REF, VOIDmode, operands[3])));
  /* Add the table address to the index.  */
  emit_insn (gen_addsi3 (reg, reg, tableaddress));
  /* Load the table entry.  */
  mem = gen_rtx (MEM, CASE_VECTOR_MODE, reg);
  RTX_UNCHANGING_P (mem);

  if (! TARGET_BIG_SWITCH)
    {
      rtx reg2 = gen_reg_rtx (HImode);
      emit_insn (gen_movhi (reg2, mem));
      emit_insn (gen_extendhisi2 (reg, reg2));
    }
  else
    emit_insn (gen_movsi (reg, mem));
  /* Add the table address.  */
  emit_insn (gen_addsi3 (reg, reg, tableaddress));
  /* Branch to the switch label.  */
  emit_jump_insn (gen_tablejump (reg, operands[3]));
  DONE;
}")

;; Call subroutine with no return value.

(define_expand "call"
  [(call (match_operand:QI 0 "general_operand" "")
	 (match_operand:SI 1 "general_operand" ""))]
  ""
  "
{
  if (! call_address_operand (XEXP (operands[0], 0))
      || TARGET_LONG_CALLS)
    XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));
  if (TARGET_LONG_CALLS)
    emit_call_insn (gen_call_internal_long (XEXP (operands[0], 0), operands[1]));
  else
    emit_call_insn (gen_call_internal_short (XEXP (operands[0], 0), operands[1]));
  
  DONE;
}")

(define_insn "call_internal_short"
  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
	 (match_operand:SI 1 "general_operand" "g,g"))
   (clobber (reg:SI 31))]
  "! TARGET_LONG_CALLS"
  "@
  jal %0
  jal .+4\;add 4,r31\;jmp %0"
  [(set_attr "length" "4,8")]
)

(define_insn "call_internal_long"
  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
	 (match_operand:SI 1 "general_operand" "g,g"))
   (clobber (reg:SI 31))]
  "TARGET_LONG_CALLS"
  "*
  {
  if (which_alternative == 0)
    {
      if (GET_CODE (operands[0]) == REG)
        return \"jal %0\";
      else
        return \"movhi hi(%0), r0, r11\;movea lo(%0), r11, r11\;jal .+4\;add 4, r31\;jmp r11\";
    }
  else
    return \"jal .+4\;add 4,r31\;jmp %0\";
  }"
  [(set_attr "length" "16,8")]
)

;; Call subroutine, returning value in operand 0
;; (which must be a hard register).

(define_expand "call_value"
  [(set (match_operand 0 "" "")
	(call (match_operand:QI 1 "general_operand" "")
	      (match_operand:SI 2 "general_operand" "")))]
  ""
  "
{
  if (! call_address_operand (XEXP (operands[1], 0))
      || TARGET_LONG_CALLS)
    XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));
  if (TARGET_LONG_CALLS)
    emit_call_insn (gen_call_value_internal_long (operands[0],
	 				          XEXP (operands[1], 0),
					          operands[2]));
  else
    emit_call_insn (gen_call_value_internal_short (operands[0],
	 				           XEXP (operands[1], 0),
					           operands[2]));
  DONE;
}")

(define_insn "call_value_internal_short"
  [(set (match_operand 0 "" "=r,r")
	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
	      (match_operand:SI 2 "general_operand" "g,g")))
   (clobber (reg:SI 31))]
  "! TARGET_LONG_CALLS"
  "@
  jal %1
  jal .+4\;add 4,r31\;jmp %1"
  [(set_attr "length" "4,8")]
)

(define_insn "call_value_internal_long"
  [(set (match_operand 0 "" "=r,r")
	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
	      (match_operand:SI 2 "general_operand" "g,g")))
   (clobber (reg:SI 31))]
  "TARGET_LONG_CALLS"
  "*
  {
  if (which_alternative == 0)
    {
      if (GET_CODE (operands[1]) == REG)
        return \"jal %1\";
      else
      /* Reload can generate this pattern... */
        return \"movhi hi(%1), r0, r11\;movea lo(%1), r11, r11\;jal .+4\;add 4, r31\;jmp r11\";
    }
  else
    return \"jal .+4\;add 4, r31\;jmp %1\";
  }"
  [(set_attr "length" "16,8")]
)

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")
   (set_attr "cc" "none")])


;; ----------------------------------------------------------------------
;; EXTEND INSTRUCTIONS
;; ----------------------------------------------------------------------


(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(zero_extend:SI
	 (match_operand:HI 1 "register_operand" "r")))]
  ""
  "andi 65535,%1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_znv")])


(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(zero_extend:SI
	 (match_operand:QI 1 "register_operand" "r")))]
  ""
  "andi 255,%1,%0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_znv")])

;;- sign extension instructions


;; ??? This is missing a sign extend from memory pattern to match the ld.h
;; instruction.

(define_expand "extendhisi2"
  [(set (match_dup 2)
        (ashift:SI (match_operand:HI 1 "register_operand" "")
                   (const_int 16)))
   (set (match_operand:SI 0 "register_operand" "")
       (ashiftrt:SI (match_dup 2)
                     (const_int 16)))]
  ""
  "
{
  operands[1] = gen_lowpart (SImode, operands[1]);
  operands[2] = gen_reg_rtx (SImode);
}")


;; ??? This is missing a sign extend from memory pattern to match the ld.b
;; instruction.

(define_expand "extendqisi2"
  [(set (match_dup 2)
        (ashift:SI (match_operand:QI 1 "register_operand" "")
                   (const_int 24)))
   (set (match_operand:SI 0 "register_operand" "")
        (ashiftrt:SI (match_dup 2)
                     (const_int 24)))]
  ""
  "
{
  operands[1] = gen_lowpart (SImode, operands[1]);
  operands[2] = gen_reg_rtx (SImode);
}")


;; ----------------------------------------------------------------------
;; SHIFTS
;; ----------------------------------------------------------------------

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashift:SI
	 (match_operand:SI 1 "register_operand" "0,0")
	 (match_operand:SI 2 "nonmemory_operand" "r,N")))]
  ""
  "@
  shl %2,%0
  shl %2,%0"
  [(set_attr "length" "4,2")
   (set_attr "cc" "set_znv")])

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(lshiftrt:SI
	 (match_operand:SI 1 "register_operand" "0,0")
	 (match_operand:SI 2 "nonmemory_operand" "r,N")))]
  ""
  "@
  shr %2,%0
  shr %2,%0"
  [(set_attr "length" "4,2")
   (set_attr "cc" "set_znv")])

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashiftrt:SI
	 (match_operand:SI 1 "register_operand" "0,0")
	 (match_operand:SI 2 "nonmemory_operand" "r,N")))]
  ""
  "@
  sar %2,%0
  sar %2,%0"
  [(set_attr "length" "4,2")
   (set_attr "cc" "set_znv")])

;; ----------------------------------------------------------------------
;; PROLOGUE/EPILOGUE
;; ----------------------------------------------------------------------
(define_expand "prologue"
  [(const_int 0)]
  ""
  "expand_prologue (); DONE;")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  /* Try to use the trivial return first.  Else use the
     full epilogue.  */
  if (0)
    emit_jump_insn (gen_return ());
  else
    expand_epilogue ();
  DONE;
}")

(define_insn "return"
  [(return)]
  "reload_completed && compute_frame_size (get_frame_size (), (long *)0) == 0"
  "jmp [r31]"
  [(set_attr "length" "2")
   (set_attr "cc" "none")])

(define_insn "return_internal"
  [(return)
   (use (reg:SI 31))]
  ""
  "jmp [r31]"
  [(set_attr "length" "2")
   (set_attr "cc" "none")])




;; ----------------------------------------------------------------------
;; HELPER INSTRUCTIONS for saving the prologue and epilog registers
;; ----------------------------------------------------------------------

;; This pattern will match a stack adjust RTX followed by any number of push
;; RTXs.  These RTXs will then be turned into a suitable call to a worker
;; function.


(define_insn ""
 [(match_parallel 0 "pattern_is_ok_for_prologue"
   [(set (reg:SI 3)
	 (plus:SI (reg:SI 3) (match_operand:SI 1 "immediate_operand" "i")))
    (set (mem:SI (plus:SI (reg:SI 3)
			   (match_operand:SI 2 "immediate_operand" "i")))
	 (match_operand:SI 3 "register_is_ok_for_epilogue" "r"))])]
 "TARGET_PROLOG_FUNCTION"
 "* return construct_save_jarl (operands[0]);
 "
 [(set (attr "length") (if_then_else (eq_attr "long_calls" "yes")
				     (const_string "18")
				     (const_string "6")))
  (set_attr "cc"     "clobber")])

;; This pattern will match a return RTX followed by any number of pop RTXs
;; and possible a stack adjustment as well.  These RTXs will be turned into
;; a suitable call to a worker function.

(define_insn ""
[(match_parallel 0 "pattern_is_ok_for_epilogue"
   [(return)
    (set (reg:SI 3)
	 (plus:SI (reg:SI 3) (match_operand:SI 1 "immediate_operand" "i")))
    (set (match_operand:SI 2 "register_is_ok_for_epilogue" "r")
	 (mem:SI (plus:SI (reg:SI 3)
			  (match_operand:SI 3 "immediate_operand" "i"))))])]
 "TARGET_PROLOG_FUNCTION"
 "* return construct_restore_jr (operands[0]);
 "
 [(set (attr "length") (if_then_else (eq_attr "long_calls" "yes")
				     (const_string "12")
				     (const_string "4")))
  (set_attr "cc"     "clobber")])


;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.
(define_insn "save_interrupt"
  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -20)))
   (set (mem:SI (reg:SI 3)) (reg:SI 30))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 10))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 4))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 1))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 16))) (reg:SI 31))]
  "! TARGET_LONG_CALLS"
  "*
  {
    if (TARGET_PROLOG_FUNCTION)
      return \"addi -20,sp,sp\;st.w r31,16[sp]\;jal __save_interrupt\";
    else
      return \"addi -20,sp,sp\;st.w r30,0[sp]\;st.w r10,4[sp]\;st.w gp,8[sp]\;st.w r1,12[sp]\;st.w r31,16[sp]\;movhi hi(__gp),r0,gp\;movea lo(__gp),gp,gp\";
  }"
 [(set (attr "length") (if_then_else (eq_attr "prolog_function" "yes")
				     (const_string "12")
				     (const_string "32")))
  (set_attr "cc"     "clobber")])


;; Restore r1, r4, r10, and return from the interrupt
(define_insn "restore_interrupt"
  [(return)
   (set (reg:SI 30)  (mem:SI (reg:SI 3)))
   (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 4))))
   (set (reg:SI 4) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))
   (set (reg:SI 1)  (mem:SI (plus:SI (reg:SI 3) (const_int 12))))
   (set (reg:SI 31)  (mem:SI (plus:SI (reg:SI 3) (const_int 16))))
   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 20)))]
  ""
  "*
  {
    if (TARGET_PROLOG_FUNCTION)
      return \"jr __return_interrupt\";
    else 
      return \"ld.w 0[sp],r30\;ld.w 4[sp],r10\;ld.w 8[sp],gp\;ld.w 12[sp],r1\;ld.w 16[sp],r31\;addi 20,sp,sp\;reti\";
  }"
 [(set (attr "length") (if_then_else (eq_attr "prolog_function" "yes")
				     (const_string "4")
				     (const_string "26")))
  (set_attr "cc"     "clobber")])



;; Save all registers except for the registers saved in save_interrupt when
;; an interrupt function makes a call.
;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
;; all of memory.  This blocks insns from being moved across this point.
;; This is needed because the rest of the compiler is not ready to handle
;; insns this complicated.

(define_insn "save_all_interrupt"
  [(unspec_volatile [(const_int 0)] 0)]
  "! TARGET_LONG_CALLS"
  "*
  {
    if (TARGET_PROLOG_FUNCTION)
      return \"jal __save_all_interrupt\";
    else
      return \"addi -116,sp,sp\;st.w r2,112[sp]\;st.w r5,108[sp]\;st.w r6,104[sp]\;st.w r7,100[sp]\;st.w r8,96[sp]\;st.w r9,92[sp]\;st.w r11,88[sp]\;st.w r12,84[sp]\;st.w r13,80[sp]\;st.w r14,76[sp]\;st.w r15,72[sp]\;st.w r16,68[sp]\;st.w r17,64[sp]\;st.w r18,60[sp]\;st.w r19,56[sp]\;st.w r20,52[sp]\;st.w r21,48[sp]\;st.w r22,44[sp]\;st.w r23,40[sp]\;st.w r24,36[sp]\;st.w r25,32[sp]\;st.w r26,28[sp]\;st.w r27,24[sp]\;st.w r28,20[sp]\;st.w r29,16[sp]\";
  }"
 [(set (attr "length") (if_then_else (eq_attr "prolog_function" "yes")
				     (const_string "6")
				     (const_string "104")))
  (set_attr "cc"     "clobber")])


;; Restore all registers saved when an interrupt function makes a call.
;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
;; all of memory.  This blocks insns from being moved across this point.
;; This is needed because the rest of the compiler is not ready to handle
;; insns this complicated.

(define_insn "restore_all_interrupt"
  [(unspec_volatile [(const_int 0)] 1)]
  "! TARGET_LONG_CALLS"
  "*
  {
    if (TARGET_PROLOG_FUNCTION)
      return \"jal __restore_all_interrupt\";
    else
      return \"ld.w 112[sp],r2\;ld.w 108[sp],r5\;ld.w 104[sp],r6\;ld.w 100[sp],r7\;ld.w 96[sp],r8\;ld.w 92[sp],r9\;ld.w 88[sp],r11\;ld.w 84[sp],r12\;ld.w 80[sp],r13\;ld.w 76[sp],r14\;ld.w 72[sp],r15\;ld.w 68[sp],r16\;ld.w 64[sp],r17\;ld.w 60[sp],r18\;ld.w 56[sp],r19\;ld.w 52[sp],r20\;ld.w 48[sp],r21\;ld.w 44[sp],r22\;ld.w 40[sp],r23\;ld.w 36[sp],r24\;ld.w 32[sp],r25\;ld.w 28[sp],r26\;ld.w 24[sp],r27\;ld.w 20[sp],r28\;ld.w 16[sp],r29\;addi 116,sp,sp\";
  }"
 [(set (attr "length") (if_then_else (eq_attr "prolog_function" "yes")
				     (const_string "4")
				     (const_string "104")))
  (set_attr "cc"     "clobber")])


;; Save r6-r9 for a variable argument function
(define_insn "save_r6_r9"
  [(set (mem:SI (reg:SI 3)) (reg:SI 6))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))
   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))
   (clobber (reg:SI 10))]
  "TARGET_PROLOG_FUNCTION && ! TARGET_LONG_CALLS"
  "mov r31,r10\;jal __save_r6_r9"
  [(set_attr "length" "4")
   (set_attr "cc" "clobber")])
